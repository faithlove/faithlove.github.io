<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JUC四大并发类的简单介绍]]></title>
    <url>%2F2018%2F08%2F10%2FJUC%E5%9B%9B%E5%A4%A7%E5%B9%B6%E5%8F%91%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[有人在群里问JUC的四大并发类该怎么用？记不住怎么办？于是乎本着复习加导学的目的写了简单的用例，在此记录一下 CountDownLatchCountDownLatch一般用于主线程等待所有子线程执行完毕的场景，比如：老师要等所有的小朋友集合了才带他们回教室。下面是个例子：12345678910111213141516171819202122232425262728293031323334353637383940package Concurrentimport java.util.concurrent.CountDownLatchimport java.util.concurrent.LinkedBlockingDequeimport java.util.concurrent.ThreadPoolExecutorimport java.util.concurrent.TimeUnit/** * describe: CountDownLatch 示例 * author: kaithmy * date: 2018/8/10 17:03 **/fun main(args: Array&lt;String&gt;) &#123; val threadPoolExecutor = ThreadPoolExecutor(10, 20, 10, TimeUnit.SECONDS, LinkedBlockingDeque()) //队伍总共5个位置 val countDownLatch = CountDownLatch(5) println("老师: $&#123;Thread.currentThread().name&#125; 孩子们，该集合啦！ ") //总共5个小朋友 for (i in 1..5) &#123; threadPoolExecutor.execute &#123; println("小朋友: $&#123;Thread.currentThread().name&#125; 我来啦！奔跑ing") Thread.sleep((i * 1000).toLong()) println("小朋友: $&#123;Thread.currentThread().name&#125; 到位！yeah！ ") //占用一个队伍位置 countDownLatch.countDown() &#125; &#125; //等待队伍位置被占满 countDownLatch.await() //队伍位置满了就回教室啦 println("老师: $&#123;Thread.currentThread().name&#125; 既然都到了，那我们回教室吧！ ")&#125; 执行结果如下：123456789101112老师: main 孩子们，该集合啦！ 小朋友: pool-1-thread-1 我来啦！奔跑ing小朋友: pool-1-thread-2 我来啦！奔跑ing小朋友: pool-1-thread-3 我来啦！奔跑ing小朋友: pool-1-thread-4 我来啦！奔跑ing小朋友: pool-1-thread-5 我来啦！奔跑ing小朋友: pool-1-thread-1 到位！yeah！ 小朋友: pool-1-thread-2 到位！yeah！ 小朋友: pool-1-thread-3 到位！yeah！ 小朋友: pool-1-thread-4 到位！yeah！ 小朋友: pool-1-thread-5 到位！yeah！ 老师: main 既然都到了，那我们回教室吧！ CyclicBarrierCyclicBarrier一般用于子线程间等待，就绪后再同时执行，具体执行顺序由CPU进行调度，比如：老师举行一次吃零食大赛，要等5位选手到齐了才能开始比赛。1234567891011121314151617181920212223242526272829303132package Concurrentimport java.util.concurrent.*/** * describe: CyclicBarrier 示例 * author: kaithmy * date: 2018/8/7 14:59 **/fun main(args: Array&lt;String&gt;) &#123; val threadPoolExecutor = ThreadPoolExecutor(10, 20, 10, TimeUnit.SECONDS, LinkedBlockingDeque()) //总共5个比赛名额 val cyclicBarrier = CyclicBarrier(5, Runnable &#123; println("老师: 人到齐了，比赛开始！") &#125;) //总共5个小朋友参赛 for (i in 1..5) &#123; threadPoolExecutor.execute &#123; println("小朋友$i:我准备好啦！") //等待其他小朋友到场 cyclicBarrier.await() println("小朋友$i:我开始吃了！") //模拟吃饭时长 Thread.sleep((i * 1000).toLong()) println("小朋友$i:我吃完了！") &#125; &#125;&#125; 执行结果如下：12345678910111213141516小朋友2:我准备好啦！小朋友3:我准备好啦！小朋友1:我准备好啦！小朋友4:我准备好啦！小朋友5:我准备好啦！老师: 人到齐了，比赛开始！小朋友5:我开始吃了！小朋友2:我开始吃了！小朋友1:我开始吃了！小朋友3:我开始吃了！小朋友4:我开始吃了！小朋友1:我吃完了！小朋友2:我吃完了！小朋友3:我吃完了！小朋友4:我吃完了！小朋友5:我吃完了！ FutureFuture适用于需要即时获取子线程的执行结果的情况，可在获取结果时设置超时时间控制获取结果的时机，以免阻塞。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package Concurrentimport java.util.concurrent.Callableimport java.util.concurrent.LinkedBlockingDequeimport java.util.concurrent.ThreadPoolExecutorimport java.util.concurrent.TimeUnit/** * describe: Future 示例 * author: kaithmy * date: 2018/8/10 15:35 **/fun main(args: Array&lt;String&gt;) &#123; val threadPoolExecutor = ThreadPoolExecutor(10, 20, 10, TimeUnit.SECONDS, LinkedBlockingDeque()) for (i in 1..5) &#123; //提交callable并获取future对象 val future = threadPoolExecutor.submit(MyFutureTask(i.toString(), i)) try &#123; //通过future获取执行结果，并设置超时时间为2s val result = future.get(2, TimeUnit.SECONDS) println("Thread $i ：拿到结果啦！是 $result 哦") &#125; catch (e: Exception) &#123; println("Thread $i ：超时了呢，$e ") //超时取消 future.cancel(true) &#125; &#125;&#125;class MyFutureTask(var name: String, var second: Int) : Callable&lt;Int&gt; &#123; override fun call(): Int &#123; println("子线程：$name 开始") //模拟耗时操作 Thread.sleep((second * 1000).toLong()) println("子线程：$name 结束，耗时：$second 秒") //返回执行结果 return second &#125;&#125; 执行结果下：123456789101112子线程：1 开始子线程：1 结束，耗时：1 秒Thread 1 ：拿到结果啦！是 1 哦子线程：2 开始子线程：2 结束，耗时：2 秒Thread 2 ：拿到结果啦！是 2 哦子线程：3 开始Thread 3 ：超时了呢，java.util.concurrent.TimeoutException 子线程：4 开始Thread 4 ：超时了呢，java.util.concurrent.TimeoutException 子线程：5 开始Thread 5 ：超时了呢，java.util.concurrent.TimeoutException SemaphoreSemaphore通常用于子线程间争夺临界资源的场景，所以他们需要申请使用，并在使用完之后释放123456789101112131415161718192021222324252627282930313233343536373839404142434445package Concurrentimport java.util.concurrent.LinkedBlockingDequeimport java.util.concurrent.Semaphoreimport java.util.concurrent.ThreadPoolExecutorimport java.util.concurrent.TimeUnit/** * describe: Semaphore 示例 * author: kaithmy * date: 2018/8/10 16:27 **/fun main(args: Array&lt;String&gt;) &#123; val threadPoolExecutor = ThreadPoolExecutor(10, 20, 10, TimeUnit.SECONDS, LinkedBlockingDeque()) //总共有3支笔 val semaphore = Semaphore(3) //总共5位同学 for (i in 1..5) &#123; threadPoolExecutor.execute(SemaphoreThread(i.toString(), semaphore)) &#125;&#125;class SemaphoreThread(var name: String, var semaphore: Semaphore) : Runnable &#123; override fun run() &#123; try &#123; //向老师请求一支笔 semaphore.acquire() println("Thread $name 占用ing") //得到笔后签名 Thread.sleep(3 * 1000L) println("Thread $name 占用3 秒后释放") //将笔还给老师 semaphore.release() &#125; catch (e: Exception) &#123; //这里是意外情况哦 println("Thread $name 出错啦，$e") semaphore.release() &#125; &#125;&#125; 执行结果如下：12345678910Thread 1 占用ingThread 3 占用ingThread 2 占用ingThread 1 占用3 秒后释放Thread 2 占用3 秒后释放Thread 3 占用3 秒后释放Thread 5 占用ingThread 4 占用ingThread 5 占用3 秒后释放Thread 4 占用3 秒后释放 结语以上就是JUC四大常用并发类的简单解释于简单用法，如果想要获取和了解更多高级用法，请手动Google和百度哦~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F08%2Fjvm-1-java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[title: ‘jvm(1):java类的加载机制’date: 2017-10-25 21:47:40tags: JVMcategories: JVMphotos: - &quot;https://faithlove.github.io/pic/2017/jvm/topPicPre1.jpg&quot; 类加载机制的奥妙。 1、什么是类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误 加载.class文件的方式 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件 2、类的生命周期 其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 加载查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情： 通过一个类的全限定名来获取其定义的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。 连接验证：确保被加载的类的正确性 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备：为类的静态变量分配内存，并将其初始化为默认值 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： 1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为：public static int value = 3； 那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的public static指令是在程序编译后，存放于类构造器&lt;clinit&gt;（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 这里还需要注意如下几点： 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。 3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。 假设上面的类变量value被定义为： public static final int value = 3； 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中 解析：把类中的符号引用转换为直接引用 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 初始化 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式： ①声明类变量是指定初始值 ②使用静态代码块为类变量指定初始值 JVM初始化步骤 1、假如这个类还没有被加载和连接，则程序先加载并连接该类 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类 3、假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： 创建类的实例，也就是new的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如Class.forName(“com.shengsiyuan.Test”)） 初始化某个类的子类，则其父类也会被初始化 Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类 结束生命周期 在如下几种情况下，Java虚拟机将结束生命周期 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 3、类加载器寻找类加载器，先来一个小例子 package com.neo.classloader; public class ClassLoaderTest { public static void main(String[] args) { ClassLoader loader = Thread.currentThread().getContextClassLoader(); System.out.println(loader); System.out.println(loader.getParent()); System.out.println(loader.getParent().getParent()); } } 运行后，输出结果： sun.misc.Launcher$AppClassLoader@64fef26a sun.misc.Launcher$ExtClassLoader@1ddd40f3 null 从上面的结果可以看出，并没有获取到ExtClassLoader的父Loader，原因是Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。 这几种类加载器的层次关系如下图所示： 注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。 站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。 站在Java开发人员的角度来看，类加载器可以大致划分为以下三类： 启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点： 1、在执行非置信代码之前，自动验证数字签名。 2、动态地创建符合用户特定需要的定制化构建类。 3、从特定的场所取得java class，例如数据库中和网络中。 JVM类加载机制 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 4、类的加载类加载有三种方式： 1、命令行启动应用时候由JVM初始化加载 2、通过Class.forName()方法动态加载 3、通过ClassLoader.loadClass()方法动态加载 例子： package com.neo.classloader; public class loaderTest { public static void main(String[] args) throws ClassNotFoundException { ClassLoader loader = HelloWorld.class.getClassLoader(); System.out.println(loader); //使用ClassLoader.loadClass()来加载类，不会执行初始化块 loader.loadClass("Test2"); //使用Class.forName()来加载类，默认会执行初始化块 //Class.forName("Test2"); //使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 //Class.forName("Test2", false, loader); } } demo类 public class Test2 { static { System.out.println("静态初始化块执行了！"); } } 分别切换加载方式，会有不同的输出结果。 Class.forName()和ClassLoader.loadClass()区别 Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块； ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。 Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。 5、双亲委派模型双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 双亲委派机制: 1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载； 4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。 ClassLoader源码分析： public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException { return loadClass(name, false); } protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)throws ClassNotFoundException { // 首先判断该类型是否已经被加载 Class c = findLoadedClass(name); if (c == null) { //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载 try { if (parent != null) { //如果存在父类加载器，就委派给父类加载器加载 c = parent.loadClass(name, false); } else { //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name) c = findBootstrapClass0(name); } } catch (ClassNotFoundException e) { // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能 c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } 双亲委派模型意义： 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行 6、自定义类加载器通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自ClassLoader类，从上面对loadClass方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程： package com.neo.classloader; import java.io.*; public class MyClassLoader extends ClassLoader { private String root; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { byte[] classData = loadClassData(name); if (classData == null) { throw new ClassNotFoundException(); } else { return defineClass(name, classData, 0, classData.length); } } private byte[] loadClassData(String className) { String fileName = root + File.separatorChar + className.replace('.', File.separatorChar) + ".class"; try { InputStream ins = new FileInputStream(fileName); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; int length = 0; while ((length = ins.read(buffer)) != -1) { baos.write(buffer, 0, length); } return baos.toByteArray(); } catch (IOException e) { e.printStackTrace(); } return null; } public String getRoot() { return root; } public void setRoot(String root) { this.root = root; } public static void main(String[] args) { MyClassLoader classLoader = new MyClassLoader(); classLoader.setRoot("E:\\temp"); Class&lt;?&gt; testClass = null; try { testClass = classLoader.loadClass("com.neo.classloader.Test2"); Object object = testClass.newInstance(); System.out.println(object.getClass().getClassLoader()); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } } 自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意： 1、这里传递的文件名需要是类的全限定性名称，即com.paddx.test.classloading.Test格式的，因为 defineClass 方法是按这种格式进行处理的。 2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。 3、这类Test 类本身可以被 AppClassLoader类加载，因此我们不能把com/paddx/test/classloading/Test.class放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由AppClassLoader加载，而不会通过我们自定义类加载器来加载。 参考：【深入Java虚拟机】之四：类加载机制JAVA类加载机制全解析Java虚拟机类加载机制深入研究Java类加载机制Java 类加载机制详解 全文转载自：http://www.ityouknow.com/jvm/2017/08/19/class-loading-principle.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Github停用TLS 1.0和TLS 1.1引起的血案]]></title>
    <url>%2F2018%2F08%2F06%2FGithub%E5%81%9C%E7%94%A8TLS-1-0%E5%92%8CTLS-1-1%E5%BC%95%E8%B5%B7%E7%9A%84%E8%A1%80%E6%A1%88%2F</url>
    <content type="text"><![CDATA[本想整理一下之前的笔记写成文章发上来，但是新项目赶着上线，各种奇葩问题频出，也就暂时搁置了。好不容易写了抽空写了一篇居然发不上来，deploy的时候老是提示SSL Exception啥的，于是搜了一下解决方案，大多数都是说要加大git的size，其实和git的size无关，这是由于Github最近停用了TLS 1.0和v 1.1导致的。 我们停用TLSv1/TLSv1.1啦以下是原文12345678910111213141516171819202122232425262728Last year we announced the deprecation of several weak cryptographic standards. Then we provided a status update toward the end of last year outlining some changes we’d made to make the transition easier for clients. We quickly approached the February 1, 2018 cutoff date we mentioned in previous posts and, as a result, pushed back our schedule by one week. On February 8, 2018 we’ll start disabling the following:TLSv1/TLSv1.1: This applies to all HTTPS connections, including web, API, and git connections to https://github.com and https://api.github.com.diffie-hellman-group1-sha1: This applies to all SSH connections to github.comdiffie-hellman-group14-sha1: This applies to all SSH connections to github.comWe’ll disable the algorithms in two stages:February 8, 2018 19:00 UTC (11:00 am PST): Disable deprecated algorithms for one hourFebruary 22, 2018 19:00 UTC (11:00 am PST): Permanently disable deprecated algorithmsWhile only a small fraction of traffic currently makes use of the deprecated algorithms, and many clients will automatically transition and start using the new algorithms, there is invariably going to be a small fraction of clients that will be impacted. We expect most of these are older systems that are no longer maintained, but continue to access Git/the GitHub API using the deprecated algorithms. To help mitigate this, we will temporarily disable support for the deprecated algorithms for one hour on February 8, 2018 19::00 UTC. By disabling support for the deprecated algorithms for a small window, these systems will temporarily fail to connect to GitHub. We will then restore support for the deprecated algorithms and provide a two week grace period for these systems to upgrade their libraries before we disable support for the deprecated algorithms permanently on February 22, 2018.Known incompatible clientsAs noted above, the vast majority of traffic should be unaffected by this change. However, there are a few remaining clients that we anticipate will be affected. Fortunately, the majority of clients can be updated to work with TLSv1.2.Git-Credential-Manager-for-Windows &lt; v1.14.0Git-Credential-Manager-for-Windows &lt; v1.14.0 does not support TLSv1.2. This can be addressed by updating to v1.14.0.Git on Red Hat 5, &lt; 6.8, and &lt; 7.2Red Hat 5, 6, and 7 shipped with Git clients that did not support TLSv1.2. This can be addressed by updating to versions 6.8 and 7.2 (or greater) respectively. Unfortunately, Red Hat 5 does not have a point release that supports TLSv1.2. We advise that users of Red Hat 5 upgrade to a newer version of the operating system.Java releases &lt; JDK 8As noted in this blog post by Oracle, TLSv1 was used by default for JDK releases prior to JDK 8. JDK 8 changed this behavior and defaults to TLSv1.2. Any client (ex. JGit is one such popular client) that runs on older versions of the JDK is affected. This can be addressed by updating to JDK &gt;= 8 or explicitly opting in to TLSv1.2 in JDK 7 (look at the https.protocols JSSE tuning parameter). Unfortunately, versions of the JDK &lt;= 6 do not support TLSv1.2. We advise users of JDK &lt;= 6 to upgrade to a newer version of the JDK.Visual StudioVisual Studio ships with specific versions of Git for Windows and the Git Credential Manager for Windows (GCM). Microsoft has updated the latest versions of Visual Studio 2017 to work with TLSv1.2 Git servers. We advise users of Visual Studio to upgrade to the latest release by clicking on the in-product notification flag or by checking for an update directly from the IDE. Microsoft has provided additional guidance on the Visual Studio developer community support forum.ConclusionAs always, if you have any questions or concerns related to this announcement, please don’t hesitate to contact us. 如何解决？ 下载安装最新的Git Credential Manager for Windows 更新Git到最新的版本，至少要到v2.16.0 然后重启就可以了 Tips：推荐将repository改为HTTPS形式的]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不可能的需求]]></title>
    <url>%2F2018%2F08%2F02%2F%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E9%9C%80%E6%B1%82%2F</url>
    <content type="text"><![CDATA[由于开发过程中需要对图片进行处理，需要对图片获取尽可能详细的信息，比如图片的Exif通常包含一些照片拍摄修改的时间，分辨率，大小,经纬度等信息，突然一天新增了一个需求：需要获取图片是前置摄像头拍摄还是后置摄像头拍摄的。得知需求后查询了一众资料，两大搜索Google，百度，Android Developer官方文档，MediaStore中关于Image的类属性、方法，Exif等元数据解析等等，均未看到有标记前后置摄像头的属性，于是反馈，后被告知一加6拍摄的照片有相应字段，于是乎单独拿出来分析了。 不可能的需求?已知需求：获取图片是前置摄像头拍摄还是后置摄像头拍摄的尝试方法： 两大搜索(Google,Baidu) Android Developer官方文档以及MediaStore中关于Image的类属性、方法 MetaData数据分析 尝试结果： 失败 失败 图片的MetaData数据分析什么是图片的Metadata？摘一段Wiki的解释123456789101112PhotographsMetadata may be written into a digital photo file that will identify who owns it, copyright and contact information, what brand or model of camera created the file, along with exposure information (shutter speed, f-stop, etc.) and descriptive information, such as keywords about the photo, making the file or image searchable on a computer and/or the Internet. Some metadata is created by the camera and some is input by the photographer and/or software after downloading to a computer. Most digital cameras write metadata about model number, shutter speed, etc., and some enable you to edit it;[35] this functionality has been available on most Nikon DSLRs since the Nikon D3, on most new Canon cameras since the Canon EOS 7D, and on most Pentax DSLRs since the Pentax K-3. Metadata can be used to make organizing in post-production easier with the use of key-wording. Filters can be used to analyze a specific set of photographs and create selections on criteria like rating or capture time.Photographic Metadata Standards are governed by organizations that develop the following standards. They include, but are not limited to:IPTC Information Interchange Model IIM (International Press Telecommunications Council),IPTC Core Schema for XMPXMP – Extensible Metadata Platform (an ISO standard)Exif – Exchangeable image file format, Maintained by CIPA (Camera &amp; Imaging Products Association) and published by JEITA (Japan Electronics and Information Technology Industries Association)Dublin Core (Dublin Core Metadata Initiative – DCMI)PLUS (Picture Licensing Universal System).VRA Core (Visual Resource Association)[36] Wiki对Exif的解释-https://zh.wikipedia.org/wiki/EXIFWiki对XMP的解释-https://zh.wikipedia.org/wiki/XMP 如果你需要查看一张图片的MetaData信息，在不下载任何程序的情况下，当然是放网站上识别了，如：http://metapicz.com/#landing现在我有一张图使用魅族6 Note拍摄，如下：将其使用网站识别的结果如下：可以看出，除了基本的Exif信息，就没有其余的多余信息了，同时还测试了一加5T，vivo，华为，三星，小米等几部手机，都一样没有，贴个一加5T的，其他的就不贴了，如下：将其使用网站识别的结果如下：网站显示没有XMP数据，但是你如果信以为真，那你就错了，网站展示的XMP数据只是对标准XMP数据而言，但是对于非标准XMP数据，网站是不识别的。下面我不使用很专业的分析工具，我们使用PhotoShop，它用来分析图片MetaData很是方便。具体步骤 将图片使用PhotoShop打开 使用快捷键CTRL+ALT+SHFIT+I打开MetaData面板 点击原始数据 下面分别是魅族拍摄的照片的元数据和一加5T拍摄的照片的元数据魅族6 Note 前置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.6-c142 79.160924, 2017/07/13-01:06:39 "&gt; &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; &lt;rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/"&gt; &lt;xmp:CreatorTool&gt;Meizu Camera&lt;/xmp:CreatorTool&gt; &lt;xmp:ModifyDate&gt;2018-08-02T15:27:15.043670&lt;/xmp:ModifyDate&gt; &lt;xmp:CreateDate&gt;2018-08-02T15:27:15&lt;/xmp:CreateDate&gt; &lt;xmp:MetadataDate&gt;2018-08-02T15:27:15.043670&lt;/xmp:MetadataDate&gt; &lt;photoshop:DateCreated&gt;2018-08-02T15:27:15.072032704&lt;/photoshop:DateCreated&gt; &lt;photoshop:ColorMode&gt;3&lt;/photoshop:ColorMode&gt; &lt;photoshop:ICCProfile&gt;sRGB IEC61966-2.1&lt;/photoshop:ICCProfile&gt; &lt;xmpMM:DocumentID&gt;BF515DD22603ACF5DFF3D111542D91CE&lt;/xmpMM:DocumentID&gt; &lt;xmpMM:InstanceID&gt;BF515DD22603ACF5DFF3D111542D91CE&lt;/xmpMM:InstanceID&gt; &lt;dc:format&gt;image/jpeg&lt;/dc:format&gt; &lt;tiff:ImageWidth&gt;4608&lt;/tiff:ImageWidth&gt; &lt;tiff:ImageLength&gt;3456&lt;/tiff:ImageLength&gt; &lt;tiff:BitsPerSample&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/tiff:BitsPerSample&gt; &lt;tiff:PhotometricInterpretation&gt;2&lt;/tiff:PhotometricInterpretation&gt; &lt;tiff:SamplesPerPixel&gt;3&lt;/tiff:SamplesPerPixel&gt; &lt;tiff:YCbCrPositioning&gt;1&lt;/tiff:YCbCrPositioning&gt; &lt;tiff:XResolution&gt;72/1&lt;/tiff:XResolution&gt; &lt;tiff:YResolution&gt;72/1&lt;/tiff:YResolution&gt; &lt;tiff:ResolutionUnit&gt;2&lt;/tiff:ResolutionUnit&gt; &lt;tiff:Make&gt;Meizu&lt;/tiff:Make&gt; &lt;tiff:Model&gt;M6 Note&lt;/tiff:Model&gt; &lt;exif:ExifVersion&gt;0220&lt;/exif:ExifVersion&gt; &lt;exif:FlashpixVersion&gt;0100&lt;/exif:FlashpixVersion&gt; &lt;exif:ColorSpace&gt;1&lt;/exif:ColorSpace&gt; &lt;exif:ComponentsConfiguration&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;1&lt;/rdf:li&gt; &lt;rdf:li&gt;2&lt;/rdf:li&gt; &lt;rdf:li&gt;3&lt;/rdf:li&gt; &lt;rdf:li&gt;0&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ComponentsConfiguration&gt; &lt;exif:PixelXDimension&gt;4608&lt;/exif:PixelXDimension&gt; &lt;exif:PixelYDimension&gt;3456&lt;/exif:PixelYDimension&gt; &lt;exif:DateTimeOriginal&gt;2018-08-02T15:27:15&lt;/exif:DateTimeOriginal&gt; &lt;exif:ExposureTime&gt;1/50&lt;/exif:ExposureTime&gt; &lt;exif:FNumber&gt;200/100&lt;/exif:FNumber&gt; &lt;exif:ExposureProgram&gt;0&lt;/exif:ExposureProgram&gt; &lt;exif:ISOSpeedRatings&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;123&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ISOSpeedRatings&gt; &lt;exif:ShutterSpeedValue&gt;5644/1000&lt;/exif:ShutterSpeedValue&gt; &lt;exif:ApertureValue&gt;2000000/1000000&lt;/exif:ApertureValue&gt; &lt;exif:BrightnessValue&gt;248/100&lt;/exif:BrightnessValue&gt; &lt;exif:MeteringMode&gt;2&lt;/exif:MeteringMode&gt; &lt;exif:Flash rdf:parseType="Resource"&gt; &lt;exif:Fired&gt;False&lt;/exif:Fired&gt; &lt;exif:Return&gt;0&lt;/exif:Return&gt; &lt;exif:Mode&gt;2&lt;/exif:Mode&gt; &lt;exif:Function&gt;False&lt;/exif:Function&gt; &lt;exif:RedEyeMode&gt;False&lt;/exif:RedEyeMode&gt; &lt;/exif:Flash&gt; &lt;exif:FocalLength&gt;3519/1000&lt;/exif:FocalLength&gt; &lt;exif:SensingMethod&gt;2&lt;/exif:SensingMethod&gt; &lt;exif:SceneType&gt;1&lt;/exif:SceneType&gt; &lt;exif:ExposureMode&gt;0&lt;/exif:ExposureMode&gt; &lt;exif:WhiteBalance&gt;0&lt;/exif:WhiteBalance&gt; &lt;exif:FocalLengthIn35mmFilm&gt;25&lt;/exif:FocalLengthIn35mmFilm&gt; &lt;exif:SceneCaptureType&gt;0&lt;/exif:SceneCaptureType&gt; &lt;exif:SubSecTime&gt;043670&lt;/exif:SubSecTime&gt; &lt;exif:SubSecTimeOriginal&gt;043670&lt;/exif:SubSecTimeOriginal&gt; &lt;exif:SubSecTimeDigitized&gt;043670&lt;/exif:SubSecTimeDigitized&gt; &lt;exif:GPSLatitude&gt;31,12.8173N&lt;/exif:GPSLatitude&gt; &lt;exif:GPSLongitude&gt;121,27.1615E&lt;/exif:GPSLongitude&gt; &lt;exif:GPSAltitudeRef&gt;200/100&lt;/exif:GPSAltitudeRef&gt; &lt;exif:GPSAltitude&gt;0/1000&lt;/exif:GPSAltitude&gt; &lt;exif:GPSTimeStamp&gt;2018-08-02T07:27:14Z&lt;/exif:GPSTimeStamp&gt; &lt;exif:GPSImgDirectionRef&gt;M&lt;/exif:GPSImgDirectionRef&gt; &lt;exif:GPSImgDirection&gt;0/1&lt;/exif:GPSImgDirection&gt; &lt;exif:GPSProcessingMethods&gt;NETWORK&lt;/exif:GPSProcessingMethods&gt; &lt;/rdf:Description&gt; &lt;/rdf:RDF&gt;&lt;/x:xmpmeta&gt; 魅族6 Note 后置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.6-c142 79.160924, 2017/07/13-01:06:39 "&gt; &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; &lt;rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/"&gt; &lt;xmp:CreatorTool&gt;Meizu Camera&lt;/xmp:CreatorTool&gt; &lt;xmp:ModifyDate&gt;2018-08-02T15:26:52.141073&lt;/xmp:ModifyDate&gt; &lt;xmp:CreateDate&gt;2018-08-02T15:26:52&lt;/xmp:CreateDate&gt; &lt;xmp:MetadataDate&gt;2018-08-02T15:26:52.141073&lt;/xmp:MetadataDate&gt; &lt;photoshop:DateCreated&gt;2018-08-02T15:26:51.339079232&lt;/photoshop:DateCreated&gt; &lt;photoshop:ColorMode&gt;3&lt;/photoshop:ColorMode&gt; &lt;photoshop:ICCProfile&gt;sRGB IEC61966-2.1&lt;/photoshop:ICCProfile&gt; &lt;xmpMM:DocumentID&gt;0782F6701AFCAD765F7A8E128F350371&lt;/xmpMM:DocumentID&gt; &lt;xmpMM:InstanceID&gt;0782F6701AFCAD765F7A8E128F350371&lt;/xmpMM:InstanceID&gt; &lt;dc:format&gt;image/jpeg&lt;/dc:format&gt; &lt;tiff:ImageWidth&gt;3000&lt;/tiff:ImageWidth&gt; &lt;tiff:ImageLength&gt;4000&lt;/tiff:ImageLength&gt; &lt;tiff:BitsPerSample&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/tiff:BitsPerSample&gt; &lt;tiff:PhotometricInterpretation&gt;2&lt;/tiff:PhotometricInterpretation&gt; &lt;tiff:SamplesPerPixel&gt;3&lt;/tiff:SamplesPerPixel&gt; &lt;tiff:YCbCrPositioning&gt;1&lt;/tiff:YCbCrPositioning&gt; &lt;tiff:XResolution&gt;72/1&lt;/tiff:XResolution&gt; &lt;tiff:YResolution&gt;72/1&lt;/tiff:YResolution&gt; &lt;tiff:ResolutionUnit&gt;2&lt;/tiff:ResolutionUnit&gt; &lt;tiff:Make&gt;Meizu&lt;/tiff:Make&gt; &lt;tiff:Model&gt;M6 Note&lt;/tiff:Model&gt; &lt;exif:ExifVersion&gt;0220&lt;/exif:ExifVersion&gt; &lt;exif:FlashpixVersion&gt;0100&lt;/exif:FlashpixVersion&gt; &lt;exif:ColorSpace&gt;1&lt;/exif:ColorSpace&gt; &lt;exif:ComponentsConfiguration&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;1&lt;/rdf:li&gt; &lt;rdf:li&gt;2&lt;/rdf:li&gt; &lt;rdf:li&gt;3&lt;/rdf:li&gt; &lt;rdf:li&gt;0&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ComponentsConfiguration&gt; &lt;exif:PixelXDimension&gt;3000&lt;/exif:PixelXDimension&gt; &lt;exif:PixelYDimension&gt;4000&lt;/exif:PixelYDimension&gt; &lt;exif:DateTimeOriginal&gt;2018-08-02T15:26:52&lt;/exif:DateTimeOriginal&gt; &lt;exif:ExposureTime&gt;1/25&lt;/exif:ExposureTime&gt; &lt;exif:FNumber&gt;190/100&lt;/exif:FNumber&gt; &lt;exif:ExposureProgram&gt;0&lt;/exif:ExposureProgram&gt; &lt;exif:ISOSpeedRatings&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;109&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ISOSpeedRatings&gt; &lt;exif:ShutterSpeedValue&gt;4643/1000&lt;/exif:ShutterSpeedValue&gt; &lt;exif:ApertureValue&gt;1851999/1000000&lt;/exif:ApertureValue&gt; &lt;exif:BrightnessValue&gt;132/100&lt;/exif:BrightnessValue&gt; &lt;exif:MeteringMode&gt;2&lt;/exif:MeteringMode&gt; &lt;exif:Flash rdf:parseType="Resource"&gt; &lt;exif:Fired&gt;False&lt;/exif:Fired&gt; &lt;exif:Return&gt;0&lt;/exif:Return&gt; &lt;exif:Mode&gt;2&lt;/exif:Mode&gt; &lt;exif:Function&gt;False&lt;/exif:Function&gt; &lt;exif:RedEyeMode&gt;False&lt;/exif:RedEyeMode&gt; &lt;/exif:Flash&gt; &lt;exif:FocalLength&gt;3940/1000&lt;/exif:FocalLength&gt; &lt;exif:SensingMethod&gt;2&lt;/exif:SensingMethod&gt; &lt;exif:SceneType&gt;1&lt;/exif:SceneType&gt; &lt;exif:ExposureMode&gt;0&lt;/exif:ExposureMode&gt; &lt;exif:WhiteBalance&gt;0&lt;/exif:WhiteBalance&gt; &lt;exif:FocalLengthIn35mmFilm&gt;24&lt;/exif:FocalLengthIn35mmFilm&gt; &lt;exif:SceneCaptureType&gt;0&lt;/exif:SceneCaptureType&gt; &lt;exif:SubSecTime&gt;141073&lt;/exif:SubSecTime&gt; &lt;exif:SubSecTimeOriginal&gt;141073&lt;/exif:SubSecTimeOriginal&gt; &lt;exif:SubSecTimeDigitized&gt;141073&lt;/exif:SubSecTimeDigitized&gt; &lt;exif:GPSLatitude&gt;31,12.8173N&lt;/exif:GPSLatitude&gt; &lt;exif:GPSLongitude&gt;121,27.1615E&lt;/exif:GPSLongitude&gt; &lt;exif:GPSAltitudeRef&gt;190/100&lt;/exif:GPSAltitudeRef&gt; &lt;exif:GPSAltitude&gt;0/1000&lt;/exif:GPSAltitude&gt; &lt;exif:GPSTimeStamp&gt;2018-08-02T07:26:43Z&lt;/exif:GPSTimeStamp&gt; &lt;exif:GPSImgDirectionRef&gt;M&lt;/exif:GPSImgDirectionRef&gt; &lt;exif:GPSImgDirection&gt;14/1&lt;/exif:GPSImgDirection&gt; &lt;exif:GPSProcessingMethods&gt;NETWORK&lt;/exif:GPSProcessingMethods&gt; &lt;/rdf:Description&gt; &lt;/rdf:RDF&gt;&lt;/x:xmpmeta&gt; OnePlus 5T 前置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.6-c142 79.160924, 2017/07/13-01:06:39 "&gt; &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; &lt;rdf:Description rdf:about="" xmlns:OPMedia="http://ns.oneplus.com/media/1.0" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/"&gt; &lt;OPMedia:CaptureMode&gt;Photo&lt;/OPMedia:CaptureMode&gt; &lt;OPMedia:IsHDRActive&gt;False&lt;/OPMedia:IsHDRActive&gt; &lt;OPMedia:LensFacing&gt;Front&lt;/OPMedia:LensFacing&gt; &lt;xmp:CreatorTool&gt;OnePlus5T-user 8.1.0 OPM1.171019.011 87 release-keys&lt;/xmp:CreatorTool&gt; &lt;xmp:ModifyDate&gt;2018-07-31T10:53:50.002856&lt;/xmp:ModifyDate&gt; &lt;xmp:CreateDate&gt;2018-07-31T10:53:50&lt;/xmp:CreateDate&gt; &lt;xmp:MetadataDate&gt;2018-07-31T10:53:50.002856&lt;/xmp:MetadataDate&gt; &lt;photoshop:DateCreated&gt;2018-07-31T10:53:48.561032704&lt;/photoshop:DateCreated&gt; &lt;photoshop:ColorMode&gt;3&lt;/photoshop:ColorMode&gt; &lt;photoshop:ICCProfile&gt;sRGB IEC61966-2.1&lt;/photoshop:ICCProfile&gt; &lt;xmpMM:DocumentID&gt;3341B1440498773B1C38052765AA3CC1&lt;/xmpMM:DocumentID&gt; &lt;xmpMM:InstanceID&gt;3341B1440498773B1C38052765AA3CC1&lt;/xmpMM:InstanceID&gt; &lt;dc:format&gt;image/jpeg&lt;/dc:format&gt; &lt;tiff:ImageWidth&gt;3456&lt;/tiff:ImageWidth&gt; &lt;tiff:ImageLength&gt;4608&lt;/tiff:ImageLength&gt; &lt;tiff:BitsPerSample&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/tiff:BitsPerSample&gt; &lt;tiff:PhotometricInterpretation&gt;2&lt;/tiff:PhotometricInterpretation&gt; &lt;tiff:SamplesPerPixel&gt;3&lt;/tiff:SamplesPerPixel&gt; &lt;tiff:YCbCrPositioning&gt;1&lt;/tiff:YCbCrPositioning&gt; &lt;tiff:XResolution&gt;72/1&lt;/tiff:XResolution&gt; &lt;tiff:YResolution&gt;72/1&lt;/tiff:YResolution&gt; &lt;tiff:ResolutionUnit&gt;2&lt;/tiff:ResolutionUnit&gt; &lt;tiff:Make&gt;OnePlus&lt;/tiff:Make&gt; &lt;tiff:Model&gt;ONEPLUS A5010&lt;/tiff:Model&gt; &lt;exif:ExifVersion&gt;0220&lt;/exif:ExifVersion&gt; &lt;exif:FlashpixVersion&gt;0100&lt;/exif:FlashpixVersion&gt; &lt;exif:ColorSpace&gt;1&lt;/exif:ColorSpace&gt; &lt;exif:ComponentsConfiguration&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;1&lt;/rdf:li&gt; &lt;rdf:li&gt;2&lt;/rdf:li&gt; &lt;rdf:li&gt;3&lt;/rdf:li&gt; &lt;rdf:li&gt;0&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ComponentsConfiguration&gt; &lt;exif:PixelXDimension&gt;3456&lt;/exif:PixelXDimension&gt; &lt;exif:PixelYDimension&gt;4608&lt;/exif:PixelYDimension&gt; &lt;exif:DateTimeOriginal&gt;2018-07-31T10:53:50&lt;/exif:DateTimeOriginal&gt; &lt;exif:ExposureTime&gt;1/25&lt;/exif:ExposureTime&gt; &lt;exif:FNumber&gt;200/100&lt;/exif:FNumber&gt; &lt;exif:ExposureProgram&gt;0&lt;/exif:ExposureProgram&gt; &lt;exif:ISOSpeedRatings&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;200&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ISOSpeedRatings&gt; &lt;exif:ShutterSpeedValue&gt;4643/1000&lt;/exif:ShutterSpeedValue&gt; &lt;exif:ApertureValue&gt;2000000/1000000&lt;/exif:ApertureValue&gt; &lt;exif:BrightnessValue&gt;0/100&lt;/exif:BrightnessValue&gt; &lt;exif:MeteringMode&gt;0&lt;/exif:MeteringMode&gt; &lt;exif:Flash rdf:parseType="Resource"&gt; &lt;exif:Fired&gt;False&lt;/exif:Fired&gt; &lt;exif:Return&gt;0&lt;/exif:Return&gt; &lt;exif:Mode&gt;2&lt;/exif:Mode&gt; &lt;exif:Function&gt;False&lt;/exif:Function&gt; &lt;exif:RedEyeMode&gt;False&lt;/exif:RedEyeMode&gt; &lt;/exif:Flash&gt; &lt;exif:FocalLength&gt;3519/1000&lt;/exif:FocalLength&gt; &lt;exif:SensingMethod&gt;2&lt;/exif:SensingMethod&gt; &lt;exif:SceneType&gt;1&lt;/exif:SceneType&gt; &lt;exif:ExposureMode&gt;0&lt;/exif:ExposureMode&gt; &lt;exif:WhiteBalance&gt;0&lt;/exif:WhiteBalance&gt; &lt;exif:FocalLengthIn35mmFilm&gt;20&lt;/exif:FocalLengthIn35mmFilm&gt; &lt;exif:SceneCaptureType&gt;0&lt;/exif:SceneCaptureType&gt; &lt;exif:SubSecTime&gt;002856&lt;/exif:SubSecTime&gt; &lt;exif:SubSecTimeOriginal&gt;002856&lt;/exif:SubSecTimeOriginal&gt; &lt;exif:SubSecTimeDigitized&gt;002856&lt;/exif:SubSecTimeDigitized&gt; &lt;exif:GPSLatitude&gt;31,12.6128N&lt;/exif:GPSLatitude&gt; &lt;exif:GPSLongitude&gt;121,27.4536E&lt;/exif:GPSLongitude&gt; &lt;exif:GPSAltitudeRef&gt;0&lt;/exif:GPSAltitudeRef&gt; &lt;exif:GPSAltitude&gt;0/1000&lt;/exif:GPSAltitude&gt; &lt;exif:GPSTimeStamp&gt;2018-07-31T02:53:48Z&lt;/exif:GPSTimeStamp&gt; &lt;/rdf:Description&gt; &lt;/rdf:RDF&gt;&lt;/x:xmpmeta&gt; OnePlus 5T 后置:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.6-c142 79.160924, 2017/07/13-01:06:39 "&gt; &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; &lt;rdf:Description rdf:about="" xmlns:OPMedia="http://ns.oneplus.com/media/1.0" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/"&gt; &lt;OPMedia:CaptureMode&gt;Photo&lt;/OPMedia:CaptureMode&gt; &lt;OPMedia:Scene&gt;AutoHDR&lt;/OPMedia:Scene&gt; &lt;OPMedia:IsHDRActive&gt;False&lt;/OPMedia:IsHDRActive&gt; &lt;OPMedia:LensFacing&gt;Back&lt;/OPMedia:LensFacing&gt; &lt;xmp:CreatorTool&gt;OnePlus5T-user 8.1.0 OPM1.171019.011 87 release-keys&lt;/xmp:CreatorTool&gt; &lt;xmp:ModifyDate&gt;2018-07-30T17:02:51.100627&lt;/xmp:ModifyDate&gt; &lt;xmp:CreateDate&gt;2018-07-30T17:02:51&lt;/xmp:CreateDate&gt; &lt;xmp:MetadataDate&gt;2018-07-30T17:02:51.100627&lt;/xmp:MetadataDate&gt; &lt;photoshop:DateCreated&gt;2018-07-30T17:02:52.842752192&lt;/photoshop:DateCreated&gt; &lt;photoshop:ColorMode&gt;3&lt;/photoshop:ColorMode&gt; &lt;photoshop:ICCProfile&gt;sRGB IEC61966-2.1&lt;/photoshop:ICCProfile&gt; &lt;xmpMM:DocumentID&gt;9FE8455EBCFE4DD43B7C0F1A77AE16AD&lt;/xmpMM:DocumentID&gt; &lt;xmpMM:InstanceID&gt;9FE8455EBCFE4DD43B7C0F1A77AE16AD&lt;/xmpMM:InstanceID&gt; &lt;dc:format&gt;image/jpeg&lt;/dc:format&gt; &lt;tiff:ImageWidth&gt;2304&lt;/tiff:ImageWidth&gt; &lt;tiff:ImageLength&gt;4608&lt;/tiff:ImageLength&gt; &lt;tiff:BitsPerSample&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/tiff:BitsPerSample&gt; &lt;tiff:PhotometricInterpretation&gt;2&lt;/tiff:PhotometricInterpretation&gt; &lt;tiff:Orientation&gt;0&lt;/tiff:Orientation&gt; &lt;tiff:SamplesPerPixel&gt;3&lt;/tiff:SamplesPerPixel&gt; &lt;tiff:YCbCrPositioning&gt;1&lt;/tiff:YCbCrPositioning&gt; &lt;tiff:XResolution&gt;72/1&lt;/tiff:XResolution&gt; &lt;tiff:YResolution&gt;72/1&lt;/tiff:YResolution&gt; &lt;tiff:ResolutionUnit&gt;2&lt;/tiff:ResolutionUnit&gt; &lt;tiff:Make&gt;OnePlus&lt;/tiff:Make&gt; &lt;tiff:Model&gt;ONEPLUS A5010&lt;/tiff:Model&gt; &lt;exif:ExifVersion&gt;0220&lt;/exif:ExifVersion&gt; &lt;exif:FlashpixVersion&gt;0100&lt;/exif:FlashpixVersion&gt; &lt;exif:ColorSpace&gt;1&lt;/exif:ColorSpace&gt; &lt;exif:ComponentsConfiguration&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;1&lt;/rdf:li&gt; &lt;rdf:li&gt;2&lt;/rdf:li&gt; &lt;rdf:li&gt;3&lt;/rdf:li&gt; &lt;rdf:li&gt;0&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ComponentsConfiguration&gt; &lt;exif:PixelXDimension&gt;2304&lt;/exif:PixelXDimension&gt; &lt;exif:PixelYDimension&gt;4608&lt;/exif:PixelYDimension&gt; &lt;exif:DateTimeOriginal&gt;2018-07-30T17:02:51&lt;/exif:DateTimeOriginal&gt; &lt;exif:ExposureTime&gt;1/33&lt;/exif:ExposureTime&gt; &lt;exif:FNumber&gt;170/100&lt;/exif:FNumber&gt; &lt;exif:ExposureProgram&gt;0&lt;/exif:ExposureProgram&gt; &lt;exif:ISOSpeedRatings&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;1000&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ISOSpeedRatings&gt; &lt;exif:ShutterSpeedValue&gt;5058/1000&lt;/exif:ShutterSpeedValue&gt; &lt;exif:ApertureValue&gt;1531069/1000000&lt;/exif:ApertureValue&gt; &lt;exif:BrightnessValue&gt;-222/100&lt;/exif:BrightnessValue&gt; &lt;exif:MeteringMode&gt;0&lt;/exif:MeteringMode&gt; &lt;exif:Flash rdf:parseType="Resource"&gt; &lt;exif:Fired&gt;False&lt;/exif:Fired&gt; &lt;exif:Return&gt;0&lt;/exif:Return&gt; &lt;exif:Mode&gt;2&lt;/exif:Mode&gt; &lt;exif:Function&gt;False&lt;/exif:Function&gt; &lt;exif:RedEyeMode&gt;False&lt;/exif:RedEyeMode&gt; &lt;/exif:Flash&gt; &lt;exif:FocalLength&gt;4103/1000&lt;/exif:FocalLength&gt; &lt;exif:SensingMethod&gt;2&lt;/exif:SensingMethod&gt; &lt;exif:SceneType&gt;1&lt;/exif:SceneType&gt; &lt;exif:ExposureMode&gt;0&lt;/exif:ExposureMode&gt; &lt;exif:WhiteBalance&gt;0&lt;/exif:WhiteBalance&gt; &lt;exif:FocalLengthIn35mmFilm&gt;24&lt;/exif:FocalLengthIn35mmFilm&gt; &lt;exif:SceneCaptureType&gt;0&lt;/exif:SceneCaptureType&gt; &lt;exif:SubSecTime&gt;100627&lt;/exif:SubSecTime&gt; &lt;exif:SubSecTimeOriginal&gt;100627&lt;/exif:SubSecTimeOriginal&gt; &lt;exif:SubSecTimeDigitized&gt;100627&lt;/exif:SubSecTimeDigitized&gt; &lt;exif:GPSLatitude&gt;31,12.6128N&lt;/exif:GPSLatitude&gt; &lt;exif:GPSLongitude&gt;121,27.4536E&lt;/exif:GPSLongitude&gt; &lt;exif:GPSAltitudeRef&gt;0&lt;/exif:GPSAltitudeRef&gt; &lt;exif:GPSAltitude&gt;0/1000&lt;/exif:GPSAltitude&gt; &lt;exif:GPSTimeStamp&gt;2018-07-30T09:02:50Z&lt;/exif:GPSTimeStamp&gt; &lt;/rdf:Description&gt; &lt;/rdf:RDF&gt;&lt;/x:xmpmeta&gt; 可以看出，一加自己定义了一个XML标签，并且使用该标签写入了自己的数据,其中&lt;OPMedia:LensFacing&gt;Back&lt;/OPMedia:LensFacing&gt;便是我们寻找的，键LensFacing对应的值为Back,表明这张图片使用后置摄像头拍摄，那么是不是所有的机型都有写入这个信息呢？下面是其他机型拍摄的照片的元数据：OnePlus 6 前置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.6-c142 79.160924, 2017/07/13-01:06:39 "&gt; &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; &lt;rdf:Description rdf:about="" xmlns:OPMedia="http://ns.oneplus.com/media/1.0" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/"&gt; &lt;OPMedia:CaptureMode&gt;Photo&lt;/OPMedia:CaptureMode&gt; &lt;OPMedia:Scene&gt;AutoHDR&lt;/OPMedia:Scene&gt; &lt;OPMedia:IsHDRActive&gt;False&lt;/OPMedia:IsHDRActive&gt; &lt;OPMedia:LensFacing&gt;Front&lt;/OPMedia:LensFacing&gt; &lt;xmp:ModifyDate&gt;2018-08-01T09:57:04.333801&lt;/xmp:ModifyDate&gt; &lt;xmp:CreateDate&gt;2018-08-01T09:57:04&lt;/xmp:CreateDate&gt; &lt;xmp:MetadataDate&gt;2018-08-01T09:57:04.333801&lt;/xmp:MetadataDate&gt; &lt;photoshop:DateCreated&gt;2018-08-01T09:57:02.793550912&lt;/photoshop:DateCreated&gt; &lt;photoshop:ColorMode&gt;3&lt;/photoshop:ColorMode&gt; &lt;photoshop:ICCProfile&gt;sRGB IEC61966-2.1&lt;/photoshop:ICCProfile&gt; &lt;xmpMM:DocumentID&gt;037F51FB2EE58CABACEA2D3E5655CECB&lt;/xmpMM:DocumentID&gt; &lt;xmpMM:InstanceID&gt;037F51FB2EE58CABACEA2D3E5655CECB&lt;/xmpMM:InstanceID&gt; &lt;dc:format&gt;image/jpeg&lt;/dc:format&gt; &lt;tiff:ImageWidth&gt;4608&lt;/tiff:ImageWidth&gt; &lt;tiff:ImageLength&gt;3456&lt;/tiff:ImageLength&gt; &lt;tiff:BitsPerSample&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/tiff:BitsPerSample&gt; &lt;tiff:PhotometricInterpretation&gt;2&lt;/tiff:PhotometricInterpretation&gt; &lt;tiff:Orientation&gt;1&lt;/tiff:Orientation&gt; &lt;tiff:SamplesPerPixel&gt;3&lt;/tiff:SamplesPerPixel&gt; &lt;tiff:YCbCrPositioning&gt;1&lt;/tiff:YCbCrPositioning&gt; &lt;tiff:XResolution&gt;72/1&lt;/tiff:XResolution&gt; &lt;tiff:YResolution&gt;72/1&lt;/tiff:YResolution&gt; &lt;tiff:ResolutionUnit&gt;2&lt;/tiff:ResolutionUnit&gt; &lt;tiff:Make&gt;OnePlus&lt;/tiff:Make&gt; &lt;tiff:Model&gt;ONEPLUS A6000&lt;/tiff:Model&gt; &lt;exif:ExifVersion&gt;0220&lt;/exif:ExifVersion&gt; &lt;exif:FlashpixVersion&gt;0100&lt;/exif:FlashpixVersion&gt; &lt;exif:ColorSpace&gt;1&lt;/exif:ColorSpace&gt; &lt;exif:ComponentsConfiguration&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;1&lt;/rdf:li&gt; &lt;rdf:li&gt;2&lt;/rdf:li&gt; &lt;rdf:li&gt;3&lt;/rdf:li&gt; &lt;rdf:li&gt;0&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ComponentsConfiguration&gt; &lt;exif:PixelXDimension&gt;4608&lt;/exif:PixelXDimension&gt; &lt;exif:PixelYDimension&gt;3456&lt;/exif:PixelYDimension&gt; &lt;exif:DateTimeOriginal&gt;2018-08-01T09:57:04&lt;/exif:DateTimeOriginal&gt; &lt;exif:ExposureTime&gt;500/10000&lt;/exif:ExposureTime&gt; &lt;exif:FNumber&gt;20000/10000&lt;/exif:FNumber&gt; &lt;exif:ExposureProgram&gt;2&lt;/exif:ExposureProgram&gt; &lt;exif:ISOSpeedRatings&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;500&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ISOSpeedRatings&gt; &lt;exif:ShutterSpeedValue&gt;5058/1000&lt;/exif:ShutterSpeedValue&gt; &lt;exif:ApertureValue&gt;2000000/1000000&lt;/exif:ApertureValue&gt; &lt;exif:BrightnessValue&gt;-316/100&lt;/exif:BrightnessValue&gt; &lt;exif:ExposureBiasValue&gt;0/6&lt;/exif:ExposureBiasValue&gt; &lt;exif:MaxApertureValue&gt;153/100&lt;/exif:MaxApertureValue&gt; &lt;exif:MeteringMode&gt;1&lt;/exif:MeteringMode&gt; &lt;exif:LightSource&gt;0&lt;/exif:LightSource&gt; &lt;exif:Flash rdf:parseType="Resource"&gt; &lt;exif:Fired&gt;False&lt;/exif:Fired&gt; &lt;exif:Return&gt;0&lt;/exif:Return&gt; &lt;exif:Mode&gt;3&lt;/exif:Mode&gt; &lt;exif:Function&gt;False&lt;/exif:Function&gt; &lt;exif:RedEyeMode&gt;False&lt;/exif:RedEyeMode&gt; &lt;/exif:Flash&gt; &lt;exif:FocalLength&gt;3480/1000&lt;/exif:FocalLength&gt; &lt;exif:SensingMethod&gt;1&lt;/exif:SensingMethod&gt; &lt;exif:ExposureMode&gt;0&lt;/exif:ExposureMode&gt; &lt;exif:WhiteBalance&gt;0&lt;/exif:WhiteBalance&gt; &lt;exif:FocalLengthIn35mmFilm&gt;25&lt;/exif:FocalLengthIn35mmFilm&gt; &lt;exif:SceneCaptureType&gt;0&lt;/exif:SceneCaptureType&gt; &lt;exif:SubSecTime&gt;333801&lt;/exif:SubSecTime&gt; &lt;exif:SubSecTimeOriginal&gt;333801&lt;/exif:SubSecTimeOriginal&gt; &lt;exif:SubSecTimeDigitized&gt;333801&lt;/exif:SubSecTimeDigitized&gt; &lt;exif:GPSLatitude&gt;31,12.7098&lt;/exif:GPSLatitude&gt; &lt;exif:GPSLongitude&gt;121,27.4435E&lt;/exif:GPSLongitude&gt; &lt;exif:GPSAltitudeRef&gt;0&lt;/exif:GPSAltitudeRef&gt; &lt;exif:GPSAltitude&gt;0/1000&lt;/exif:GPSAltitude&gt; &lt;exif:GPSTimeStamp&gt;2018-08-01T01:57:04Z&lt;/exif:GPSTimeStamp&gt; &lt;/rdf:Description&gt; &lt;/rdf:RDF&gt;&lt;/x:xmpmeta&gt; OnePlus 6 后置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.6-c142 79.160924, 2017/07/13-01:06:39 "&gt; &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; &lt;rdf:Description rdf:about="" xmlns:OPMedia="http://ns.oneplus.com/media/1.0" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/"&gt; &lt;OPMedia:CaptureMode&gt;Photo&lt;/OPMedia:CaptureMode&gt; &lt;OPMedia:Scene&gt;AutoHDR&lt;/OPMedia:Scene&gt; &lt;OPMedia:IsHDRActive&gt;False&lt;/OPMedia:IsHDRActive&gt; &lt;OPMedia:LensFacing&gt;Back&lt;/OPMedia:LensFacing&gt; &lt;xmp:ModifyDate&gt;2018-05-25T17:21:18.333801&lt;/xmp:ModifyDate&gt; &lt;xmp:CreateDate&gt;2018-05-25T17:21:18&lt;/xmp:CreateDate&gt; &lt;xmp:MetadataDate&gt;2018-05-25T17:21:18.333801&lt;/xmp:MetadataDate&gt; &lt;photoshop:DateCreated&gt;2018-05-25T17:21:16.793550912&lt;/photoshop:DateCreated&gt; &lt;photoshop:ColorMode&gt;3&lt;/photoshop:ColorMode&gt; &lt;photoshop:ICCProfile&gt;sRGB IEC61966-2.1&lt;/photoshop:ICCProfile&gt; &lt;xmpMM:DocumentID&gt;2C0E6CBC34D567743E5B9DF66D8FF4AF&lt;/xmpMM:DocumentID&gt; &lt;xmpMM:InstanceID&gt;2C0E6CBC34D567743E5B9DF66D8FF4AF&lt;/xmpMM:InstanceID&gt; &lt;dc:format&gt;image/jpeg&lt;/dc:format&gt; &lt;tiff:ImageWidth&gt;4608&lt;/tiff:ImageWidth&gt; &lt;tiff:ImageLength&gt;3456&lt;/tiff:ImageLength&gt; &lt;tiff:BitsPerSample&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/tiff:BitsPerSample&gt; &lt;tiff:PhotometricInterpretation&gt;2&lt;/tiff:PhotometricInterpretation&gt; &lt;tiff:Orientation&gt;1&lt;/tiff:Orientation&gt; &lt;tiff:SamplesPerPixel&gt;3&lt;/tiff:SamplesPerPixel&gt; &lt;tiff:YCbCrPositioning&gt;1&lt;/tiff:YCbCrPositioning&gt; &lt;tiff:XResolution&gt;72/1&lt;/tiff:XResolution&gt; &lt;tiff:YResolution&gt;72/1&lt;/tiff:YResolution&gt; &lt;tiff:ResolutionUnit&gt;2&lt;/tiff:ResolutionUnit&gt; &lt;tiff:Make&gt;OnePlus&lt;/tiff:Make&gt; &lt;tiff:Model&gt;ONEPLUS A6000&lt;/tiff:Model&gt; &lt;exif:ExifVersion&gt;0220&lt;/exif:ExifVersion&gt; &lt;exif:FlashpixVersion&gt;0100&lt;/exif:FlashpixVersion&gt; &lt;exif:ColorSpace&gt;1&lt;/exif:ColorSpace&gt; &lt;exif:ComponentsConfiguration&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;1&lt;/rdf:li&gt; &lt;rdf:li&gt;2&lt;/rdf:li&gt; &lt;rdf:li&gt;3&lt;/rdf:li&gt; &lt;rdf:li&gt;0&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ComponentsConfiguration&gt; &lt;exif:PixelXDimension&gt;4608&lt;/exif:PixelXDimension&gt; &lt;exif:PixelYDimension&gt;3456&lt;/exif:PixelYDimension&gt; &lt;exif:DateTimeOriginal&gt;2018-05-25T17:21:18&lt;/exif:DateTimeOriginal&gt; &lt;exif:ExposureTime&gt;100/10000&lt;/exif:ExposureTime&gt; &lt;exif:FNumber&gt;17000/10000&lt;/exif:FNumber&gt; &lt;exif:ExposureProgram&gt;2&lt;/exif:ExposureProgram&gt; &lt;exif:ISOSpeedRatings&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;400&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ISOSpeedRatings&gt; &lt;exif:ShutterSpeedValue&gt;5058/1000&lt;/exif:ShutterSpeedValue&gt; &lt;exif:ApertureValue&gt;1531069/1000000&lt;/exif:ApertureValue&gt; &lt;exif:BrightnessValue&gt;-316/100&lt;/exif:BrightnessValue&gt; &lt;exif:ExposureBiasValue&gt;0/6&lt;/exif:ExposureBiasValue&gt; &lt;exif:MaxApertureValue&gt;153/100&lt;/exif:MaxApertureValue&gt; &lt;exif:MeteringMode&gt;1&lt;/exif:MeteringMode&gt; &lt;exif:LightSource&gt;0&lt;/exif:LightSource&gt; &lt;exif:Flash rdf:parseType="Resource"&gt; &lt;exif:Fired&gt;False&lt;/exif:Fired&gt; &lt;exif:Return&gt;0&lt;/exif:Return&gt; &lt;exif:Mode&gt;3&lt;/exif:Mode&gt; &lt;exif:Function&gt;False&lt;/exif:Function&gt; &lt;exif:RedEyeMode&gt;False&lt;/exif:RedEyeMode&gt; &lt;/exif:Flash&gt; &lt;exif:FocalLength&gt;4250/1000&lt;/exif:FocalLength&gt; &lt;exif:SensingMethod&gt;1&lt;/exif:SensingMethod&gt; &lt;exif:ExposureMode&gt;0&lt;/exif:ExposureMode&gt; &lt;exif:WhiteBalance&gt;0&lt;/exif:WhiteBalance&gt; &lt;exif:FocalLengthIn35mmFilm&gt;25&lt;/exif:FocalLengthIn35mmFilm&gt; &lt;exif:SceneCaptureType&gt;0&lt;/exif:SceneCaptureType&gt; &lt;exif:SubSecTime&gt;333801&lt;/exif:SubSecTime&gt; &lt;exif:SubSecTimeOriginal&gt;333801&lt;/exif:SubSecTimeOriginal&gt; &lt;exif:SubSecTimeDigitized&gt;333801&lt;/exif:SubSecTimeDigitized&gt; &lt;exif:GPSLatitude&gt;31,12.7104&lt;/exif:GPSLatitude&gt; &lt;exif:GPSLongitude&gt;121,27.4342E&lt;/exif:GPSLongitude&gt; &lt;exif:GPSAltitudeRef&gt;0&lt;/exif:GPSAltitudeRef&gt; &lt;exif:GPSAltitude&gt;0/1000&lt;/exif:GPSAltitude&gt; &lt;exif:GPSTimeStamp&gt;2018-05-25T09:21:18Z&lt;/exif:GPSTimeStamp&gt; &lt;/rdf:Description&gt; &lt;/rdf:RDF&gt;&lt;/x:xmpmeta&gt; vivo X9 前置:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.6-c142 79.160924, 2017/07/13-01:06:39 "&gt; &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; &lt;rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/"&gt; &lt;xmp:CreatorTool&gt;msm8953_64-user 7.1.2 N2G47H eng.compil.20180716.175053 release-keys&lt;/xmp:CreatorTool&gt; &lt;xmp:ModifyDate&gt;2018-08-02T14:48:40.675561&lt;/xmp:ModifyDate&gt; &lt;xmp:CreateDate&gt;2018-08-02T14:48:40&lt;/xmp:CreateDate&gt; &lt;xmp:MetadataDate&gt;2018-08-02T14:48:40.675561&lt;/xmp:MetadataDate&gt; &lt;photoshop:DateCreated&gt;2018-08-02T14:48:41.251134528&lt;/photoshop:DateCreated&gt; &lt;photoshop:ColorMode&gt;3&lt;/photoshop:ColorMode&gt; &lt;photoshop:ICCProfile&gt;sRGB IEC61966-2.1&lt;/photoshop:ICCProfile&gt; &lt;xmpMM:DocumentID&gt;37EE2F012E274C22C2D5506C2A1902CF&lt;/xmpMM:DocumentID&gt; &lt;xmpMM:InstanceID&gt;37EE2F012E274C22C2D5506C2A1902CF&lt;/xmpMM:InstanceID&gt; &lt;dc:format&gt;image/jpeg&lt;/dc:format&gt; &lt;tiff:ImageWidth&gt;3840&lt;/tiff:ImageWidth&gt; &lt;tiff:ImageLength&gt;5120&lt;/tiff:ImageLength&gt; &lt;tiff:BitsPerSample&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/tiff:BitsPerSample&gt; &lt;tiff:PhotometricInterpretation&gt;2&lt;/tiff:PhotometricInterpretation&gt; &lt;tiff:SamplesPerPixel&gt;3&lt;/tiff:SamplesPerPixel&gt; &lt;tiff:YCbCrPositioning&gt;1&lt;/tiff:YCbCrPositioning&gt; &lt;tiff:XResolution&gt;72/1&lt;/tiff:XResolution&gt; &lt;tiff:YResolution&gt;72/1&lt;/tiff:YResolution&gt; &lt;tiff:ResolutionUnit&gt;2&lt;/tiff:ResolutionUnit&gt; &lt;tiff:Make&gt;vivo&lt;/tiff:Make&gt; &lt;tiff:Model&gt;vivo X9&lt;/tiff:Model&gt; &lt;exif:ExifVersion&gt;0220&lt;/exif:ExifVersion&gt; &lt;exif:FlashpixVersion&gt;0100&lt;/exif:FlashpixVersion&gt; &lt;exif:ColorSpace&gt;1&lt;/exif:ColorSpace&gt; &lt;exif:ComponentsConfiguration&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;1&lt;/rdf:li&gt; &lt;rdf:li&gt;2&lt;/rdf:li&gt; &lt;rdf:li&gt;3&lt;/rdf:li&gt; &lt;rdf:li&gt;0&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ComponentsConfiguration&gt; &lt;exif:PixelXDimension&gt;3840&lt;/exif:PixelXDimension&gt; &lt;exif:PixelYDimension&gt;5120&lt;/exif:PixelYDimension&gt; &lt;exif:DateTimeOriginal&gt;2018-08-02T14:48:40&lt;/exif:DateTimeOriginal&gt; &lt;exif:ExposureTime&gt;10/333&lt;/exif:ExposureTime&gt; &lt;exif:FNumber&gt;200/100&lt;/exif:FNumber&gt; &lt;exif:ExposureProgram&gt;0&lt;/exif:ExposureProgram&gt; &lt;exif:ISOSpeedRatings&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;311&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ISOSpeedRatings&gt; &lt;exif:ShutterSpeedValue&gt;5058/1000&lt;/exif:ShutterSpeedValue&gt; &lt;exif:ApertureValue&gt;2000000/1000000&lt;/exif:ApertureValue&gt; &lt;exif:BrightnessValue&gt;59/100&lt;/exif:BrightnessValue&gt; &lt;exif:MeteringMode&gt;2&lt;/exif:MeteringMode&gt; &lt;exif:Flash rdf:parseType="Resource"&gt; &lt;exif:Fired&gt;False&lt;/exif:Fired&gt; &lt;exif:Return&gt;0&lt;/exif:Return&gt; &lt;exif:Mode&gt;0&lt;/exif:Mode&gt; &lt;exif:Function&gt;False&lt;/exif:Function&gt; &lt;exif:RedEyeMode&gt;False&lt;/exif:RedEyeMode&gt; &lt;/exif:Flash&gt; &lt;exif:FocalLength&gt;387/100&lt;/exif:FocalLength&gt; &lt;exif:SensingMethod&gt;2&lt;/exif:SensingMethod&gt; &lt;exif:SceneType&gt;1&lt;/exif:SceneType&gt; &lt;exif:ExposureMode&gt;0&lt;/exif:ExposureMode&gt; &lt;exif:WhiteBalance&gt;0&lt;/exif:WhiteBalance&gt; &lt;exif:FocalLengthIn35mmFilm&gt;26&lt;/exif:FocalLengthIn35mmFilm&gt; &lt;exif:SceneCaptureType&gt;0&lt;/exif:SceneCaptureType&gt; &lt;exif:SubSecTime&gt;675561&lt;/exif:SubSecTime&gt; &lt;exif:SubSecTimeOriginal&gt;675561&lt;/exif:SubSecTimeOriginal&gt; &lt;exif:SubSecTimeDigitized&gt;675561&lt;/exif:SubSecTimeDigitized&gt; &lt;exif:GPSAltitudeRef&gt;200/100&lt;/exif:GPSAltitudeRef&gt; &lt;exif:GPSTimeStamp&gt;2018-08-02T06:48:40Z&lt;/exif:GPSTimeStamp&gt; &lt;/rdf:Description&gt; &lt;/rdf:RDF&gt;&lt;/x:xmpmeta&gt; vivo X9 后置:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.6-c142 79.160924, 2017/07/13-01:06:39 "&gt; &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; &lt;rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/"&gt; &lt;xmp:CreatorTool&gt;msm8953_64-user 7.1.2 N2G47H eng.compil.20180716.175053 release-keys&lt;/xmp:CreatorTool&gt; &lt;xmp:ModifyDate&gt;2018-08-02T14:48:14.666509&lt;/xmp:ModifyDate&gt; &lt;xmp:CreateDate&gt;2018-08-02T14:48:14&lt;/xmp:CreateDate&gt; &lt;xmp:MetadataDate&gt;2018-08-02T14:48:14.666509&lt;/xmp:MetadataDate&gt; &lt;photoshop:DateCreated&gt;2018-08-02T14:48:14.78906912&lt;/photoshop:DateCreated&gt; &lt;photoshop:ColorMode&gt;3&lt;/photoshop:ColorMode&gt; &lt;photoshop:ICCProfile&gt;sRGB IEC61966-2.1&lt;/photoshop:ICCProfile&gt; &lt;xmpMM:DocumentID&gt;5EFA5DBFD6539AE7059A28B40B79AEAE&lt;/xmpMM:DocumentID&gt; &lt;xmpMM:InstanceID&gt;5EFA5DBFD6539AE7059A28B40B79AEAE&lt;/xmpMM:InstanceID&gt; &lt;dc:format&gt;image/jpeg&lt;/dc:format&gt; &lt;tiff:ImageWidth&gt;3456&lt;/tiff:ImageWidth&gt; &lt;tiff:ImageLength&gt;4608&lt;/tiff:ImageLength&gt; &lt;tiff:BitsPerSample&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/tiff:BitsPerSample&gt; &lt;tiff:PhotometricInterpretation&gt;2&lt;/tiff:PhotometricInterpretation&gt; &lt;tiff:SamplesPerPixel&gt;3&lt;/tiff:SamplesPerPixel&gt; &lt;tiff:YCbCrPositioning&gt;1&lt;/tiff:YCbCrPositioning&gt; &lt;tiff:XResolution&gt;72/1&lt;/tiff:XResolution&gt; &lt;tiff:YResolution&gt;72/1&lt;/tiff:YResolution&gt; &lt;tiff:ResolutionUnit&gt;2&lt;/tiff:ResolutionUnit&gt; &lt;tiff:Make&gt;vivo&lt;/tiff:Make&gt; &lt;tiff:Model&gt;vivo X9&lt;/tiff:Model&gt; &lt;exif:ExifVersion&gt;0220&lt;/exif:ExifVersion&gt; &lt;exif:FlashpixVersion&gt;0100&lt;/exif:FlashpixVersion&gt; &lt;exif:ColorSpace&gt;1&lt;/exif:ColorSpace&gt; &lt;exif:ComponentsConfiguration&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;1&lt;/rdf:li&gt; &lt;rdf:li&gt;2&lt;/rdf:li&gt; &lt;rdf:li&gt;3&lt;/rdf:li&gt; &lt;rdf:li&gt;0&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ComponentsConfiguration&gt; &lt;exif:PixelXDimension&gt;3456&lt;/exif:PixelXDimension&gt; &lt;exif:PixelYDimension&gt;4608&lt;/exif:PixelYDimension&gt; &lt;exif:DateTimeOriginal&gt;2018-08-02T14:48:14&lt;/exif:DateTimeOriginal&gt; &lt;exif:ExposureTime&gt;10/333&lt;/exif:ExposureTime&gt; &lt;exif:FNumber&gt;200/100&lt;/exif:FNumber&gt; &lt;exif:ExposureProgram&gt;0&lt;/exif:ExposureProgram&gt; &lt;exif:ISOSpeedRatings&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;320&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ISOSpeedRatings&gt; &lt;exif:ShutterSpeedValue&gt;5058/1000&lt;/exif:ShutterSpeedValue&gt; &lt;exif:ApertureValue&gt;2000000/1000000&lt;/exif:ApertureValue&gt; &lt;exif:BrightnessValue&gt;34/100&lt;/exif:BrightnessValue&gt; &lt;exif:MeteringMode&gt;2&lt;/exif:MeteringMode&gt; &lt;exif:Flash rdf:parseType="Resource"&gt; &lt;exif:Fired&gt;False&lt;/exif:Fired&gt; &lt;exif:Return&gt;0&lt;/exif:Return&gt; &lt;exif:Mode&gt;0&lt;/exif:Mode&gt; &lt;exif:Function&gt;False&lt;/exif:Function&gt; &lt;exif:RedEyeMode&gt;False&lt;/exif:RedEyeMode&gt; &lt;/exif:Flash&gt; &lt;exif:FocalLength&gt;388/100&lt;/exif:FocalLength&gt; &lt;exif:SensingMethod&gt;2&lt;/exif:SensingMethod&gt; &lt;exif:SceneType&gt;1&lt;/exif:SceneType&gt; &lt;exif:ExposureMode&gt;0&lt;/exif:ExposureMode&gt; &lt;exif:WhiteBalance&gt;0&lt;/exif:WhiteBalance&gt; &lt;exif:FocalLengthIn35mmFilm&gt;26&lt;/exif:FocalLengthIn35mmFilm&gt; &lt;exif:SceneCaptureType&gt;0&lt;/exif:SceneCaptureType&gt; &lt;exif:SubSecTime&gt;666509&lt;/exif:SubSecTime&gt; &lt;exif:SubSecTimeOriginal&gt;666509&lt;/exif:SubSecTimeOriginal&gt; &lt;exif:SubSecTimeDigitized&gt;666509&lt;/exif:SubSecTimeDigitized&gt; &lt;exif:GPSAltitudeRef&gt;200/100&lt;/exif:GPSAltitudeRef&gt; &lt;exif:GPSTimeStamp&gt;2018-08-02T06:48:14Z&lt;/exif:GPSTimeStamp&gt; &lt;/rdf:Description&gt; &lt;/rdf:RDF&gt;&lt;/x:xmpmeta&gt; Pixel 2 前置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.6-c142 79.160924, 2017/07/13-01:06:39 "&gt; &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; &lt;rdf:Description rdf:about="" xmlns:GCamera="http://ns.google.com/photos/1.0/camera/" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:aux="http://ns.adobe.com/exif/1.0/aux/" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/"&gt; &lt;GCamera:MicroVideo&gt;1&lt;/GCamera:MicroVideo&gt; &lt;GCamera:MicroVideoVersion&gt;1&lt;/GCamera:MicroVideoVersion&gt; &lt;GCamera:MicroVideoOffset&gt;1691842&lt;/GCamera:MicroVideoOffset&gt; &lt;GCamera:MicroVideoPresentationTimestampUs&gt;233612&lt;/GCamera:MicroVideoPresentationTimestampUs&gt; &lt;xmp:CreatorTool&gt;HDR+ 1.0.198487984zb&lt;/xmp:CreatorTool&gt; &lt;xmp:ModifyDate&gt;2018-08-02T14:41:39.404620&lt;/xmp:ModifyDate&gt; &lt;xmp:CreateDate&gt;2018-08-02T14:41:39&lt;/xmp:CreateDate&gt; &lt;xmp:MetadataDate&gt;2018-08-02T14:41:39.404620&lt;/xmp:MetadataDate&gt; &lt;aux:ApproximateFocusDistance&gt;0/1&lt;/aux:ApproximateFocusDistance&gt; &lt;photoshop:DateCreated&gt;2018-08-02T14:41:40.807294336&lt;/photoshop:DateCreated&gt; &lt;photoshop:ColorMode&gt;3&lt;/photoshop:ColorMode&gt; &lt;photoshop:ICCProfile&gt;sRGB IEC61966-2.1&lt;/photoshop:ICCProfile&gt; &lt;xmpMM:DocumentID&gt;4B7EC3C4B26F6A5AF1C59D786A893518&lt;/xmpMM:DocumentID&gt; &lt;xmpMM:InstanceID&gt;4B7EC3C4B26F6A5AF1C59D786A893518&lt;/xmpMM:InstanceID&gt; &lt;dc:format&gt;image/jpeg&lt;/dc:format&gt; &lt;tiff:ImageWidth&gt;3264&lt;/tiff:ImageWidth&gt; &lt;tiff:ImageLength&gt;2448&lt;/tiff:ImageLength&gt; &lt;tiff:BitsPerSample&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/tiff:BitsPerSample&gt; &lt;tiff:PhotometricInterpretation&gt;2&lt;/tiff:PhotometricInterpretation&gt; &lt;tiff:Orientation&gt;1&lt;/tiff:Orientation&gt; &lt;tiff:SamplesPerPixel&gt;3&lt;/tiff:SamplesPerPixel&gt; &lt;tiff:YCbCrPositioning&gt;1&lt;/tiff:YCbCrPositioning&gt; &lt;tiff:XResolution&gt;72/1&lt;/tiff:XResolution&gt; &lt;tiff:YResolution&gt;72/1&lt;/tiff:YResolution&gt; &lt;tiff:ResolutionUnit&gt;2&lt;/tiff:ResolutionUnit&gt; &lt;tiff:Make&gt;Google&lt;/tiff:Make&gt; &lt;tiff:Model&gt;Pixel 2&lt;/tiff:Model&gt; &lt;exif:ExifVersion&gt;0220&lt;/exif:ExifVersion&gt; &lt;exif:FlashpixVersion&gt;0100&lt;/exif:FlashpixVersion&gt; &lt;exif:ColorSpace&gt;1&lt;/exif:ColorSpace&gt; &lt;exif:PixelXDimension&gt;3264&lt;/exif:PixelXDimension&gt; &lt;exif:PixelYDimension&gt;2448&lt;/exif:PixelYDimension&gt; &lt;exif:DateTimeOriginal&gt;2018-08-02T14:41:39&lt;/exif:DateTimeOriginal&gt; &lt;exif:ExposureTime&gt;33333/1000000&lt;/exif:ExposureTime&gt; &lt;exif:FNumber&gt;240/100&lt;/exif:FNumber&gt; &lt;exif:ExposureProgram&gt;2&lt;/exif:ExposureProgram&gt; &lt;exif:ISOSpeedRatings&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;119&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ISOSpeedRatings&gt; &lt;exif:ShutterSpeedValue&gt;491/100&lt;/exif:ShutterSpeedValue&gt; &lt;exif:ApertureValue&gt;2526069/1000000&lt;/exif:ApertureValue&gt; &lt;exif:BrightnessValue&gt;218/100&lt;/exif:BrightnessValue&gt; &lt;exif:ExposureBiasValue&gt;0/6&lt;/exif:ExposureBiasValue&gt; &lt;exif:MaxApertureValue&gt;253/100&lt;/exif:MaxApertureValue&gt; &lt;exif:SubjectDistance&gt;0/1&lt;/exif:SubjectDistance&gt; &lt;exif:MeteringMode&gt;2&lt;/exif:MeteringMode&gt; &lt;exif:Flash rdf:parseType="Resource"&gt; &lt;exif:Fired&gt;False&lt;/exif:Fired&gt; &lt;exif:Return&gt;0&lt;/exif:Return&gt; &lt;exif:Mode&gt;2&lt;/exif:Mode&gt; &lt;exif:Function&gt;False&lt;/exif:Function&gt; &lt;exif:RedEyeMode&gt;False&lt;/exif:RedEyeMode&gt; &lt;/exif:Flash&gt; &lt;exif:FocalLength&gt;3380/1000&lt;/exif:FocalLength&gt; &lt;exif:SensingMethod&gt;2&lt;/exif:SensingMethod&gt; &lt;exif:SceneType&gt;1&lt;/exif:SceneType&gt; &lt;exif:CustomRendered&gt;1&lt;/exif:CustomRendered&gt; &lt;exif:ExposureMode&gt;0&lt;/exif:ExposureMode&gt; &lt;exif:WhiteBalance&gt;0&lt;/exif:WhiteBalance&gt; &lt;exif:DigitalZoomRatio&gt;0/1&lt;/exif:DigitalZoomRatio&gt; &lt;exif:FocalLengthIn35mmFilm&gt;25&lt;/exif:FocalLengthIn35mmFilm&gt; &lt;exif:SceneCaptureType&gt;0&lt;/exif:SceneCaptureType&gt; &lt;exif:Contrast&gt;0&lt;/exif:Contrast&gt; &lt;exif:Saturation&gt;0&lt;/exif:Saturation&gt; &lt;exif:Sharpness&gt;0&lt;/exif:Sharpness&gt; &lt;exif:SubjectDistanceRange&gt;0&lt;/exif:SubjectDistanceRange&gt; &lt;exif:SubSecTime&gt;404620&lt;/exif:SubSecTime&gt; &lt;exif:SubSecTimeOriginal&gt;404620&lt;/exif:SubSecTimeOriginal&gt; &lt;exif:SubSecTimeDigitized&gt;404620&lt;/exif:SubSecTimeDigitized&gt; &lt;exif:GPSVersionID&gt;2.2.0.0&lt;/exif:GPSVersionID&gt; &lt;exif:GPSLatitude&gt;31,12.826N&lt;/exif:GPSLatitude&gt; &lt;exif:GPSLongitude&gt;121,27.1655E&lt;/exif:GPSLongitude&gt; &lt;exif:GPSAltitudeRef&gt;0&lt;/exif:GPSAltitudeRef&gt; &lt;exif:GPSAltitude&gt;3220/100&lt;/exif:GPSAltitude&gt; &lt;exif:GPSTimeStamp&gt;2018-08-02T06:41:29Z&lt;/exif:GPSTimeStamp&gt; &lt;exif:GPSDOP&gt;15812/1000&lt;/exif:GPSDOP&gt; &lt;exif:GPSProcessingMethods&gt;fused&lt;/exif:GPSProcessingMethods&gt; &lt;/rdf:Description&gt; &lt;/rdf:RDF&gt;&lt;/x:xmpmeta&gt; Pixel 2 后置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.6-c142 79.160924, 2017/07/13-01:06:39 "&gt; &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; &lt;rdf:Description rdf:about="" xmlns:GCamera="http://ns.google.com/photos/1.0/camera/" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:aux="http://ns.adobe.com/exif/1.0/aux/" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/"&gt; &lt;GCamera:MicroVideo&gt;1&lt;/GCamera:MicroVideo&gt; &lt;GCamera:MicroVideoVersion&gt;1&lt;/GCamera:MicroVideoVersion&gt; &lt;GCamera:MicroVideoOffset&gt;2470328&lt;/GCamera:MicroVideoOffset&gt; &lt;GCamera:MicroVideoPresentationTimestampUs&gt;799652&lt;/GCamera:MicroVideoPresentationTimestampUs&gt; &lt;xmp:CreatorTool&gt;HDR+ 1.0.198487984z&lt;/xmp:CreatorTool&gt; &lt;xmp:ModifyDate&gt;2018-08-02T14:41:46.148686&lt;/xmp:ModifyDate&gt; &lt;xmp:CreateDate&gt;2018-08-02T14:41:46&lt;/xmp:CreateDate&gt; &lt;xmp:MetadataDate&gt;2018-08-02T14:41:46.148686&lt;/xmp:MetadataDate&gt; &lt;aux:ApproximateFocusDistance&gt;588/1000&lt;/aux:ApproximateFocusDistance&gt; &lt;photoshop:DateCreated&gt;2018-08-02T14:41:44.36214464&lt;/photoshop:DateCreated&gt; &lt;photoshop:ColorMode&gt;3&lt;/photoshop:ColorMode&gt; &lt;photoshop:ICCProfile&gt;sRGB IEC61966-2.1&lt;/photoshop:ICCProfile&gt; &lt;xmpMM:DocumentID&gt;C6041F60CBB2044037D860457E7203A4&lt;/xmpMM:DocumentID&gt; &lt;xmpMM:InstanceID&gt;C6041F60CBB2044037D860457E7203A4&lt;/xmpMM:InstanceID&gt; &lt;dc:format&gt;image/jpeg&lt;/dc:format&gt; &lt;tiff:ImageWidth&gt;3024&lt;/tiff:ImageWidth&gt; &lt;tiff:ImageLength&gt;4032&lt;/tiff:ImageLength&gt; &lt;tiff:BitsPerSample&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/tiff:BitsPerSample&gt; &lt;tiff:PhotometricInterpretation&gt;2&lt;/tiff:PhotometricInterpretation&gt; &lt;tiff:Orientation&gt;1&lt;/tiff:Orientation&gt; &lt;tiff:SamplesPerPixel&gt;3&lt;/tiff:SamplesPerPixel&gt; &lt;tiff:YCbCrPositioning&gt;1&lt;/tiff:YCbCrPositioning&gt; &lt;tiff:XResolution&gt;72/1&lt;/tiff:XResolution&gt; &lt;tiff:YResolution&gt;72/1&lt;/tiff:YResolution&gt; &lt;tiff:ResolutionUnit&gt;2&lt;/tiff:ResolutionUnit&gt; &lt;tiff:Make&gt;Google&lt;/tiff:Make&gt; &lt;tiff:Model&gt;Pixel 2&lt;/tiff:Model&gt; &lt;exif:ExifVersion&gt;0220&lt;/exif:ExifVersion&gt; &lt;exif:FlashpixVersion&gt;0100&lt;/exif:FlashpixVersion&gt; &lt;exif:ColorSpace&gt;1&lt;/exif:ColorSpace&gt; &lt;exif:PixelXDimension&gt;3024&lt;/exif:PixelXDimension&gt; &lt;exif:PixelYDimension&gt;4032&lt;/exif:PixelYDimension&gt; &lt;exif:DateTimeOriginal&gt;2018-08-02T14:41:46&lt;/exif:DateTimeOriginal&gt; &lt;exif:ExposureTime&gt;10002/1000000&lt;/exif:ExposureTime&gt; &lt;exif:FNumber&gt;180/100&lt;/exif:FNumber&gt; &lt;exif:ExposureProgram&gt;2&lt;/exif:ExposureProgram&gt; &lt;exif:ISOSpeedRatings&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;127&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ISOSpeedRatings&gt; &lt;exif:ShutterSpeedValue&gt;664/100&lt;/exif:ShutterSpeedValue&gt; &lt;exif:ApertureValue&gt;1695994/1000000&lt;/exif:ApertureValue&gt; &lt;exif:BrightnessValue&gt;299/100&lt;/exif:BrightnessValue&gt; &lt;exif:ExposureBiasValue&gt;0/6&lt;/exif:ExposureBiasValue&gt; &lt;exif:MaxApertureValue&gt;170/100&lt;/exif:MaxApertureValue&gt; &lt;exif:SubjectDistance&gt;588/1000&lt;/exif:SubjectDistance&gt; &lt;exif:MeteringMode&gt;2&lt;/exif:MeteringMode&gt; &lt;exif:Flash rdf:parseType="Resource"&gt; &lt;exif:Fired&gt;False&lt;/exif:Fired&gt; &lt;exif:Return&gt;0&lt;/exif:Return&gt; &lt;exif:Mode&gt;2&lt;/exif:Mode&gt; &lt;exif:Function&gt;False&lt;/exif:Function&gt; &lt;exif:RedEyeMode&gt;False&lt;/exif:RedEyeMode&gt; &lt;/exif:Flash&gt; &lt;exif:FocalLength&gt;4442/1000&lt;/exif:FocalLength&gt; &lt;exif:SensingMethod&gt;2&lt;/exif:SensingMethod&gt; &lt;exif:SceneType&gt;1&lt;/exif:SceneType&gt; &lt;exif:CustomRendered&gt;1&lt;/exif:CustomRendered&gt; &lt;exif:ExposureMode&gt;0&lt;/exif:ExposureMode&gt; &lt;exif:WhiteBalance&gt;0&lt;/exif:WhiteBalance&gt; &lt;exif:DigitalZoomRatio&gt;0/1&lt;/exif:DigitalZoomRatio&gt; &lt;exif:FocalLengthIn35mmFilm&gt;27&lt;/exif:FocalLengthIn35mmFilm&gt; &lt;exif:SceneCaptureType&gt;0&lt;/exif:SceneCaptureType&gt; &lt;exif:Contrast&gt;0&lt;/exif:Contrast&gt; &lt;exif:Saturation&gt;0&lt;/exif:Saturation&gt; &lt;exif:Sharpness&gt;0&lt;/exif:Sharpness&gt; &lt;exif:SubjectDistanceRange&gt;1&lt;/exif:SubjectDistanceRange&gt; &lt;exif:SubSecTime&gt;148686&lt;/exif:SubSecTime&gt; &lt;exif:SubSecTimeOriginal&gt;148686&lt;/exif:SubSecTimeOriginal&gt; &lt;exif:SubSecTimeDigitized&gt;148686&lt;/exif:SubSecTimeDigitized&gt; &lt;exif:GPSVersionID&gt;2.2.0.0&lt;/exif:GPSVersionID&gt; &lt;exif:GPSLatitude&gt;31,12.826N&lt;/exif:GPSLatitude&gt; &lt;exif:GPSLongitude&gt;121,27.1655E&lt;/exif:GPSLongitude&gt; &lt;exif:GPSAltitudeRef&gt;0&lt;/exif:GPSAltitudeRef&gt; &lt;exif:GPSAltitude&gt;3220/100&lt;/exif:GPSAltitude&gt; &lt;exif:GPSTimeStamp&gt;2018-08-02T06:41:29Z&lt;/exif:GPSTimeStamp&gt; &lt;exif:GPSDOP&gt;15812/1000&lt;/exif:GPSDOP&gt; &lt;exif:GPSProcessingMethods&gt;fused&lt;/exif:GPSProcessingMethods&gt; &lt;/rdf:Description&gt; &lt;/rdf:RDF&gt;&lt;/x:xmpmeta&gt; 红米 5 Plus 前置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.6-c142 79.160924, 2017/07/13-01:06:39 "&gt; &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; &lt;rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/"&gt; &lt;xmp:CreatorTool&gt;vince-user 7.1.2 N2G47H 8.7.12 release-keys&lt;/xmp:CreatorTool&gt; &lt;xmp:ModifyDate&gt;2018-08-02T15:50:10.111306&lt;/xmp:ModifyDate&gt; &lt;xmp:CreateDate&gt;2018-08-02T15:50:10&lt;/xmp:CreateDate&gt; &lt;xmp:MetadataDate&gt;2018-08-02T15:50:10.111306&lt;/xmp:MetadataDate&gt; &lt;photoshop:DateCreated&gt;2018-08-02T15:50:09.636850304&lt;/photoshop:DateCreated&gt; &lt;photoshop:ColorMode&gt;3&lt;/photoshop:ColorMode&gt; &lt;photoshop:ICCProfile&gt;sRGB IEC61966-2.1&lt;/photoshop:ICCProfile&gt; &lt;xmpMM:DocumentID&gt;CDE79A1CEBA00CD1FC459DBA269EF0B4&lt;/xmpMM:DocumentID&gt; &lt;xmpMM:InstanceID&gt;CDE79A1CEBA00CD1FC459DBA269EF0B4&lt;/xmpMM:InstanceID&gt; &lt;dc:format&gt;image/jpeg&lt;/dc:format&gt; &lt;tiff:ImageWidth&gt;1944&lt;/tiff:ImageWidth&gt; &lt;tiff:ImageLength&gt;2592&lt;/tiff:ImageLength&gt; &lt;tiff:BitsPerSample&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/tiff:BitsPerSample&gt; &lt;tiff:PhotometricInterpretation&gt;2&lt;/tiff:PhotometricInterpretation&gt; &lt;tiff:Orientation&gt;1&lt;/tiff:Orientation&gt; &lt;tiff:SamplesPerPixel&gt;3&lt;/tiff:SamplesPerPixel&gt; &lt;tiff:YCbCrPositioning&gt;1&lt;/tiff:YCbCrPositioning&gt; &lt;tiff:XResolution&gt;72/1&lt;/tiff:XResolution&gt; &lt;tiff:YResolution&gt;72/1&lt;/tiff:YResolution&gt; &lt;tiff:ResolutionUnit&gt;2&lt;/tiff:ResolutionUnit&gt; &lt;tiff:Make&gt;Xiaomi&lt;/tiff:Make&gt; &lt;tiff:Model&gt;Redmi 5 Plus&lt;/tiff:Model&gt; &lt;exif:ExifVersion&gt;0220&lt;/exif:ExifVersion&gt; &lt;exif:FlashpixVersion&gt;0100&lt;/exif:FlashpixVersion&gt; &lt;exif:ColorSpace&gt;1&lt;/exif:ColorSpace&gt; &lt;exif:ComponentsConfiguration&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;1&lt;/rdf:li&gt; &lt;rdf:li&gt;2&lt;/rdf:li&gt; &lt;rdf:li&gt;3&lt;/rdf:li&gt; &lt;rdf:li&gt;0&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ComponentsConfiguration&gt; &lt;exif:PixelXDimension&gt;2592&lt;/exif:PixelXDimension&gt; &lt;exif:PixelYDimension&gt;1944&lt;/exif:PixelYDimension&gt; &lt;exif:DateTimeOriginal&gt;2018-08-02T15:50:10&lt;/exif:DateTimeOriginal&gt; &lt;exif:ExposureTime&gt;1/33&lt;/exif:ExposureTime&gt; &lt;exif:FNumber&gt;200/100&lt;/exif:FNumber&gt; &lt;exif:ExposureProgram&gt;0&lt;/exif:ExposureProgram&gt; &lt;exif:ISOSpeedRatings&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;242&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ISOSpeedRatings&gt; &lt;exif:ShutterSpeedValue&gt;5058/1000&lt;/exif:ShutterSpeedValue&gt; &lt;exif:ApertureValue&gt;2000000/1000000&lt;/exif:ApertureValue&gt; &lt;exif:BrightnessValue&gt;62/100&lt;/exif:BrightnessValue&gt; &lt;exif:MeteringMode&gt;2&lt;/exif:MeteringMode&gt; &lt;exif:Flash rdf:parseType="Resource"&gt; &lt;exif:Fired&gt;False&lt;/exif:Fired&gt; &lt;exif:Return&gt;0&lt;/exif:Return&gt; &lt;exif:Mode&gt;2&lt;/exif:Mode&gt; &lt;exif:Function&gt;False&lt;/exif:Function&gt; &lt;exif:RedEyeMode&gt;False&lt;/exif:RedEyeMode&gt; &lt;/exif:Flash&gt; &lt;exif:FocalLength&gt;2639/1000&lt;/exif:FocalLength&gt; &lt;exif:SensingMethod&gt;2&lt;/exif:SensingMethod&gt; &lt;exif:SceneType&gt;1&lt;/exif:SceneType&gt; &lt;exif:ExposureMode&gt;0&lt;/exif:ExposureMode&gt; &lt;exif:WhiteBalance&gt;0&lt;/exif:WhiteBalance&gt; &lt;exif:FocalLengthIn35mmFilm&gt;3&lt;/exif:FocalLengthIn35mmFilm&gt; &lt;exif:SceneCaptureType&gt;0&lt;/exif:SceneCaptureType&gt; &lt;exif:SubSecTime&gt;111306&lt;/exif:SubSecTime&gt; &lt;exif:SubSecTimeOriginal&gt;111306&lt;/exif:SubSecTimeOriginal&gt; &lt;exif:SubSecTimeDigitized&gt;111306&lt;/exif:SubSecTimeDigitized&gt; &lt;exif:GPSAltitudeRef&gt;200/100&lt;/exif:GPSAltitudeRef&gt; &lt;exif:GPSTimeStamp&gt;2018-08-02T07:50:09Z&lt;/exif:GPSTimeStamp&gt; &lt;/rdf:Description&gt; &lt;/rdf:RDF&gt;&lt;/x:xmpmeta&gt; 红米 5 Plus 后置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.6-c142 79.160924, 2017/07/13-01:06:39 "&gt; &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; &lt;rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/"&gt; &lt;xmp:CreatorTool&gt;vince-user 7.1.2 N2G47H 8.7.12 release-keys&lt;/xmp:CreatorTool&gt; &lt;xmp:ModifyDate&gt;2018-08-02T15:49:54.799201&lt;/xmp:ModifyDate&gt; &lt;xmp:CreateDate&gt;2018-08-02T15:49:54&lt;/xmp:CreateDate&gt; &lt;xmp:MetadataDate&gt;2018-08-02T15:49:54.799201&lt;/xmp:MetadataDate&gt; &lt;photoshop:DateCreated&gt;2018-08-02T15:49:54.337082944&lt;/photoshop:DateCreated&gt; &lt;photoshop:ColorMode&gt;3&lt;/photoshop:ColorMode&gt; &lt;photoshop:ICCProfile&gt;sRGB IEC61966-2.1&lt;/photoshop:ICCProfile&gt; &lt;xmpMM:DocumentID&gt;DCE86D08DEBFAFC48F5631CDA52CCB7E&lt;/xmpMM:DocumentID&gt; &lt;xmpMM:InstanceID&gt;DCE86D08DEBFAFC48F5631CDA52CCB7E&lt;/xmpMM:InstanceID&gt; &lt;dc:format&gt;image/jpeg&lt;/dc:format&gt; &lt;tiff:ImageWidth&gt;3000&lt;/tiff:ImageWidth&gt; &lt;tiff:ImageLength&gt;4000&lt;/tiff:ImageLength&gt; &lt;tiff:BitsPerSample&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;rdf:li&gt;8&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/tiff:BitsPerSample&gt; &lt;tiff:PhotometricInterpretation&gt;2&lt;/tiff:PhotometricInterpretation&gt; &lt;tiff:Orientation&gt;1&lt;/tiff:Orientation&gt; &lt;tiff:SamplesPerPixel&gt;3&lt;/tiff:SamplesPerPixel&gt; &lt;tiff:YCbCrPositioning&gt;1&lt;/tiff:YCbCrPositioning&gt; &lt;tiff:XResolution&gt;72/1&lt;/tiff:XResolution&gt; &lt;tiff:YResolution&gt;72/1&lt;/tiff:YResolution&gt; &lt;tiff:ResolutionUnit&gt;2&lt;/tiff:ResolutionUnit&gt; &lt;tiff:Make&gt;Xiaomi&lt;/tiff:Make&gt; &lt;tiff:Model&gt;Redmi 5 Plus&lt;/tiff:Model&gt; &lt;exif:ExifVersion&gt;0220&lt;/exif:ExifVersion&gt; &lt;exif:FlashpixVersion&gt;0100&lt;/exif:FlashpixVersion&gt; &lt;exif:ColorSpace&gt;1&lt;/exif:ColorSpace&gt; &lt;exif:ComponentsConfiguration&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;1&lt;/rdf:li&gt; &lt;rdf:li&gt;2&lt;/rdf:li&gt; &lt;rdf:li&gt;3&lt;/rdf:li&gt; &lt;rdf:li&gt;0&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ComponentsConfiguration&gt; &lt;exif:PixelXDimension&gt;4000&lt;/exif:PixelXDimension&gt; &lt;exif:PixelYDimension&gt;3000&lt;/exif:PixelYDimension&gt; &lt;exif:DateTimeOriginal&gt;2018-08-02T15:49:54&lt;/exif:DateTimeOriginal&gt; &lt;exif:ExposureTime&gt;1/50&lt;/exif:ExposureTime&gt; &lt;exif:FNumber&gt;220/100&lt;/exif:FNumber&gt; &lt;exif:ExposureProgram&gt;0&lt;/exif:ExposureProgram&gt; &lt;exif:ISOSpeedRatings&gt; &lt;rdf:Seq&gt; &lt;rdf:li&gt;400&lt;/rdf:li&gt; &lt;/rdf:Seq&gt; &lt;/exif:ISOSpeedRatings&gt; &lt;exif:ShutterSpeedValue&gt;5643/1000&lt;/exif:ShutterSpeedValue&gt; &lt;exif:ApertureValue&gt;2275007/1000000&lt;/exif:ApertureValue&gt; &lt;exif:BrightnessValue&gt;96/100&lt;/exif:BrightnessValue&gt; &lt;exif:MeteringMode&gt;2&lt;/exif:MeteringMode&gt; &lt;exif:Flash rdf:parseType="Resource"&gt; &lt;exif:Fired&gt;False&lt;/exif:Fired&gt; &lt;exif:Return&gt;0&lt;/exif:Return&gt; &lt;exif:Mode&gt;2&lt;/exif:Mode&gt; &lt;exif:Function&gt;False&lt;/exif:Function&gt; &lt;exif:RedEyeMode&gt;False&lt;/exif:RedEyeMode&gt; &lt;/exif:Flash&gt; &lt;exif:FocalLength&gt;3819/1000&lt;/exif:FocalLength&gt; &lt;exif:SensingMethod&gt;2&lt;/exif:SensingMethod&gt; &lt;exif:SceneType&gt;1&lt;/exif:SceneType&gt; &lt;exif:ExposureMode&gt;0&lt;/exif:ExposureMode&gt; &lt;exif:WhiteBalance&gt;0&lt;/exif:WhiteBalance&gt; &lt;exif:FocalLengthIn35mmFilm&gt;26&lt;/exif:FocalLengthIn35mmFilm&gt; &lt;exif:SceneCaptureType&gt;0&lt;/exif:SceneCaptureType&gt; &lt;exif:SubSecTime&gt;799201&lt;/exif:SubSecTime&gt; &lt;exif:SubSecTimeOriginal&gt;799201&lt;/exif:SubSecTimeOriginal&gt; &lt;exif:SubSecTimeDigitized&gt;799201&lt;/exif:SubSecTimeDigitized&gt; &lt;exif:GPSAltitudeRef&gt;220/100&lt;/exif:GPSAltitudeRef&gt; &lt;exif:GPSTimeStamp&gt;2018-08-02T07:49:54Z&lt;/exif:GPSTimeStamp&gt; &lt;/rdf:Description&gt; &lt;/rdf:RDF&gt;&lt;/x:xmpmeta&gt; 一加可行由上面的结果可知，目前只有一加在自定义属性中添加了LensFacing用来标记前后置摄像头，其余机型均为有相应字段用来标记前后置摄像头，所以在编码时只针对一加进行编码就行，若后续有其他机型也增加了标记字段，则进行补充编码即可。 编码进行时由于时间紧迫，加上重复造轮子过于复杂和耗时，我选择了metadata-extractor这个库，具体使用与示例请参照对应wiki及源码，这里贴个简陋的Demo的MainActivity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.kaithmy.metadatademoimport android.content.Intentimport android.os.Bundleimport android.support.v7.app.AppCompatActivityimport android.view.Menuimport android.view.MenuItemimport android.widget.Toastimport com.adobe.xmp.properties.XMPPropertyInfoimport com.drew.imaging.ImageMetadataReaderimport com.drew.metadata.xmp.XmpDirectoryimport kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity() &#123; val IMAGE_PICKER_REQUESTCODE = 10086 override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) setSupportActionBar(toolbar) fab.setOnClickListener &#123; view -&gt; val intent = Intent(Intent.ACTION_GET_CONTENT) intent.type = "image/*" startActivityForResult(intent, IMAGE_PICKER_REQUESTCODE) &#125; &#125; override fun onCreateOptionsMenu(menu: Menu): Boolean &#123; // Inflate the menu; this adds items to the action bar if it is present. menuInflater.inflate(R.menu.menu_main, menu) return true &#125; override fun onOptionsItemSelected(item: MenuItem): Boolean &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. return when (item.itemId) &#123; R.id.action_settings -&gt; true else -&gt; super.onOptionsItemSelected(item) &#125; &#125; override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; if (requestCode == IMAGE_PICKER_REQUESTCODE) &#123; if (data == null) return val uri = data.data try &#123; val openInputStream = contentResolver.openInputStream(uri) val metadata = ImageMetadataReader.readMetadata(openInputStream) val xmpDirectory = metadata.getDirectoriesOfType(XmpDirectory::class.java) xmpDirectory.forEach &#123; val xmpMeta = it.xmpMeta for (any in xmpMeta) &#123; if (any is XMPPropertyInfo &amp;&amp; "OPMedia:LensFacing" == any.path) &#123; if ("Front" == any.value) &#123; Toast.makeText(this, "Front", Toast.LENGTH_LONG).show() &#125; if ("Back" == any.value) &#123; Toast.makeText(this, "Back", Toast.LENGTH_LONG).show() &#125; &#125; &#125; &#125; &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; &#125; &#125;&#125; 突发情况？程序在其他手机上跑的好好的，突然在魅族6 Note上突然崩溃了，报错信息如下：123456789101112131415E/AndroidRuntime: FATAL EXCEPTION: main Process: com.kaithmy.metadatademo, PID: 26896 java.lang.NoSuchMethodError: No interface method getValue()Ljava/lang/String; in class Lcom/adobe/xmp/properties/XMPPropertyInfo; or its super classes (declaration of 'com.adobe.xmp.properties.XMPPropertyInfo' appears in /system/framework/framework.jar:classes2.dex) at com.kaithmy.metadatademo.MainActivity.onActivityResult(MainActivity.kt:57) at android.app.Activity.dispatchActivityResult(Activity.java:7060) at android.app.ActivityThread.deliverResults(ActivityThread.java:4279) at android.app.ActivityThread.handleSendResult(ActivityThread.java:4326) at android.app.ActivityThread.-wrap20(ActivityThread.java) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1640) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:154) at android.app.ActivityThread.main(ActivityThread.java:6321) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:939) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:829) 接口类方法getValue找不到？，吓得我赶紧点进去看了看123456789101112131415161718192021222324252627282930313233343536373839404142434445// =================================================================================================// ADOBE SYSTEMS INCORPORATED// Copyright 2006 Adobe Systems Incorporated// All Rights Reserved//// NOTICE: Adobe permits you to use, modify, and distribute this file in accordance with the terms// of the Adobe license agreement accompanying it.// =================================================================================================package com.adobe.xmp.properties;import com.adobe.xmp.options.PropertyOptions;/** * This interface is used to return a property together with its path and namespace. * It is returned when properties are iterated with the &lt;code&gt;XMPIterator&lt;/code&gt;. * * @since 06.07.2006 */public interface XMPPropertyInfo extends XMPProperty&#123; /** * @return Returns the namespace of the property */ String getNamespace(); /** * @return Returns the path of the property, but only if returned by the iterator. */ String getPath(); /** * @return Returns the value of the property. */ String getValue(); /** * @return Returns the options of the property. */ PropertyOptions getOptions();&#125; 其中getValue()和getOptions()继承自接口XMPProperty12345678910111213141516171819202122232425262728293031323334353637383940// =================================================================================================// ADOBE SYSTEMS INCORPORATED// Copyright 2006 Adobe Systems Incorporated// All Rights Reserved//// NOTICE: Adobe permits you to use, modify, and distribute this file in accordance with the terms// of the Adobe license agreement accompanying it.// =================================================================================================package com.adobe.xmp.properties;import com.adobe.xmp.XMPMeta;import com.adobe.xmp.options.PropertyOptions;/** * This interface is used to return a text property together with its and options. * * @since 23.01.2006 */public interface XMPProperty &#123; /** * @return Returns the value of the property. */ String getValue(); /** * @return Returns the options of the property. */ PropertyOptions getOptions(); /** * Only set by &#123;@link XMPMeta#getLocalizedText(String, String, String, String)&#125;. * @return Returns the language of the alt-text item. */ String getLanguage();&#125; 明明有啊，这不坑爹嘛这是！难道是混淆了？于是在混淆配置文件中添加了-keep class com.adobe.xmp.** { *; }，结果还是没用。查看一下生成的apk中的dex里有没有是有的，那为什么会找不到呢？看了看错误中的/system/framework/framework.jar，立即将framework.jar从手机中导了出来，但是里面居然是空的，只有个文件夹META-INF中包含一个MANIFEST.MF文件，那么问题也不在这里。仔细想了想，会不会是因为是魅族改过framework层呢，或者说是手机被root过而受了影响呢？于是乎借了一部root过的Nexus 5装上了验证Demo进行测试，结果是能正常运行并展示结果，由此排除了受root而导致的接口方法找不到。 结语基于以上验证结果，浅显地认为是魅族的ROM导致的吧ㄟ( ▔, ▔ )ㄏ]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next如何在文章摘要展示图片]]></title>
    <url>%2F2018%2F07%2F18%2FHexo-Next%E5%A6%82%E4%BD%95%E5%9C%A8%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%B1%95%E7%A4%BA%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[由于之前的文章一直没有配图，并且在文章摘要中出现代码会出现乱码字符现象，于是乎想要给每篇文章配图，避免这种现象，同时配上图的摘要感觉很好看 在文章的属性列表中添加photos属性编写的文章属性中photos默认为文章的配图，这是我目前最喜欢的配图方式，但是有一个缺点，它不能自定义裁剪和缩略比，展示的是原图，这相当于如果你的每张配图大小比例不一致将会很影响美观性，目前没有很好的解决方案，所以只好自己裁剪好再引入。如这篇文章：12345678---title: Hexo Next如何在文章摘要展示图片date: 2018-07-18 17:43:44tags: Hexocategories: Hexophotos: - "https://faithlove.github.io/pic/2018/HexoThumb/topPicPre.png"--- 在你的正文中使用&lt;!-- more --&gt;进行截断由于markdown是支持原生html的，所以我们可以在正文引用img来为我们的文章设置摘要配图,在&lt;!-- more --&gt;之前的内容都会展示到摘要中(同时与你主题文件中配置的摘要字数有关).如：123456789---title: Hexo Next如何在文章摘要展示图片date: 2018-07-18 17:43:44tags: Hexocategories: Hexo---&lt;img src="https://faithlove.github.io/pic/2018/RMTP_1/topPicPre.png" width=50% /&gt;哇，漂亮的小姐姐(❤ ω ❤)&lt;!--more--&gt; 参考： https://segmentfault.com/q/1010000004840061]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教你从零搭建RMTP直播推流服务]]></title>
    <url>%2F2018%2F07%2F17%2F%E6%95%99%E4%BD%A0%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BARMTP%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[之前由于向同学分享内容的时候发现手机端没有屏幕共享的应用，而直播软件大都需要实名注册，并且没有房间密码，隐私性很低，不符合需求，于是想自己开发一款，但苦于时间不允许，由此开个坑，慢慢填。 市面上的第三方直播推流供应商很多，集成起来也很方便，但是大都需要付费，而且价格不菲，于是乎决定自行搭建服务，同时加深对推流服务的理解。 开发环境Linux,Nginx(OpenResty),nginx-rtmp-module 什么是OpenResty基于官网的介绍，OpenResty® 是一个基于 Nginx 与 Lua 的高性能 Web 平台,详细介绍大家去官网看吧，这里就不多做解释了。 卸载或替换之前的nginx版本如果你已经有安装过nginx，那么请备份好自己的数据，在此我将安装nginx,并展示如何卸载它，由于我自己的nginx里什么内容都没有，所以我进行完全卸载(以下命令全部在root下进行)。123456789101112131415161718192021222324252627282930313233343536373839#安装启动过程省略//停止nginxroot@VM-53-84-ubuntu:/home/ubuntu# nginx -s stop//查找nginx位置root@VM-53-84-ubuntu:/home/ubuntu# whereis nginxnginx: /usr/sbin/nginx /etc/nginx /usr/share/nginx//使用apt移除卸载nginxroot@VM-53-84-ubuntu:/home/ubuntu# apt --purge remove nginxReading package lists... DoneBuilding dependency treeReading state information... DonePackage 'nginx' is not installed, so not removedThe following packages were automatically installed and are no longer required: libgd3 libvpx3 libxpm4 libxslt1.1 linux-headers-4.4.0-124 linux-headers-4.4.0-124-generic linux-headers-4.4.0-127 linux-headers-4.4.0-127-generic linux-image-4.4.0-124-generic linux-image-4.4.0-127-generic linux-image-extra-4.4.0-124-generic linux-image-extra-4.4.0-127-generic nginx-common nginx-coreUse 'apt autoremove' to remove them.0 upgraded, 0 newly installed, 0 to remove and 25 not upgraded.//查找nginx位置root@VM-53-84-ubuntu:/home/ubuntu# whereis nginxnginx: /usr/sbin/nginx /etc/nginx /usr/share/nginx//删除/usr/sbin/nginxroot@VM-53-84-ubuntu:/home/ubuntu# rm -r /usr/sbin/nginx//删除/etc/nginxroot@VM-53-84-ubuntu:/home/ubuntu# rm -r /etc/nginx//删除/usr/share/nginx/root@VM-53-84-ubuntu:/home/ubuntu# rm -r /usr/share/nginx/root@VM-53-84-ubuntu:/home/ubuntu# whereis nginxnginx://查看nginx进程root@VM-53-84-ubuntu:/home/ubuntu# ps -ef | grep nginxroot 7970 7499 0 19:18 pts/0 00:00:00 grep --color=auto nginx 下载安装OpenResty到官网下载最新的安装包并安装，具体过程请参考OpenResty-安装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//下载nginx压缩包root@VM-53-84-ubuntu:/home/ubuntu/RMTP# wget https://openresty.org/download/openresty-1.13.6.2.tar.gz--2018-07-18 19:21:35-- https://openresty.org/download/openresty-1.13.6.2.tar.gzResolving openresty.org (openresty.org)... 120.24.93.123Connecting to openresty.org (openresty.org)|120.24.93.123|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 4635916 (4.4M) [application/x-gzip]Saving to: ‘openresty-1.13.6.2.tar.gz’openresty-1.13.6.2.tar.gz 100%[====================================================================&gt;] 4.42M 5.13MB/s in 0.9s2018-07-18 19:21:36 (5.13 MB/s) - ‘openresty-1.13.6.2.tar.gz’ saved [4635916/4635916]//解压root@VM-53-84-ubuntu:/home/ubuntu/RMTP# tar -zxf openresty-1.13.6.2.tar.gz//安装必要类库root@VM-53-84-ubuntu:/home/ubuntu/RMTP# apt-get install libpcre3-dev \&gt; libssl-dev perl make build-essential curlReading package lists... DoneBuilding dependency treeReading state information... Donebuild-essential is already the newest version (12.1ubuntu2).libpcre3-dev is already the newest version (2:8.38-3.1).make is already the newest version (4.1-6).curl is already the newest version (7.47.0-1ubuntu2.8).libssl-dev is already the newest version (1.0.2g-1ubuntu4.13).perl is already the newest version (5.22.1-9ubuntu0.5).The following packages were automatically installed and are no longer required: libgd3 libvpx3 libxpm4 libxslt1.1 linux-headers-4.4.0-124 linux-headers-4.4.0-124-generic linux-headers-4.4.0-127 linux-headers-4.4.0-127-generic linux-image-4.4.0-124-generic linux-image-4.4.0-127-generic linux-image-extra-4.4.0-124-generic linux-image-extra-4.4.0-127-generic nginx-common nginx-coreUse 'apt autoremove' to remove them.0 upgraded, 0 newly installed, 0 to remove and 25 not upgraded.//进入openresty的文件夹root@VM-53-84-ubuntu:/home/ubuntu/RMTP# cd openresty-1.13.6.2//生成编译配置文件root@VM-53-84-ubuntu:/home/ubuntu/RMTP/openresty-1.13.6.2# ./configureplatform: linux (linux)cp -rp bundle/ buildcd buildcd LuaJIT-2.1-20180420INFO: found -msse4.2 in cc.make TARGET_STRIP=@: CCDEBUG=-g XCFLAGS='-DLUAJIT_ENABLE_LUA52COMPAT -msse4.2' CC=cc PREFIX=/usr/local/openresty/luajit==== Building LuaJIT 2.1.0-beta3 ====make -C srcmake[1]: Entering directory '/home/ubuntu/RMTP/openresty-1.13.6.2/build/LuaJIT-2.1-20180420/src'HOSTCC host/minilua.oHOSTLINK host/miniluaDYNASM host/buildvm_arch.h//省略一部分输出。。。。。creating objs/MakefileConfiguration summary + using system PCRE library + using system OpenSSL library + using system zlib library nginx path prefix: "/usr/local/openresty/nginx" nginx binary file: "/usr/local/openresty/nginx/sbin/nginx" nginx modules path: "/usr/local/openresty/nginx/modules" nginx configuration prefix: "/usr/local/openresty/nginx/conf" nginx configuration file: "/usr/local/openresty/nginx/conf/nginx.conf" nginx pid file: "/usr/local/openresty/nginx/logs/nginx.pid" nginx error log file: "/usr/local/openresty/nginx/logs/error.log" nginx http access log file: "/usr/local/openresty/nginx/logs/access.log" nginx http client request body temporary files: "client_body_temp" nginx http proxy temporary files: "proxy_temp" nginx http fastcgi temporary files: "fastcgi_temp" nginx http uwsgi temporary files: "uwsgi_temp" nginx http scgi temporary files: "scgi_temp"cd ../..Type the following commands to build and install: make make installroot@VM-53-84-ubuntu:/home/ubuntu/RMTP/openresty-1.13.6.2# make //编译//省略一部分输出。。。。。objs/addon/src/ngx_stream_lua_ssl.o \objs/addon/src/ngx_stream_lua_balancer.o \objs/addon/src/ngx_stream_lua_logby.o \objs/addon/src/ngx_stream_lua_prereadby.o \objs/ngx_modules.o \-L/home/ubuntu/RMTP/openresty-1.13.6.2/build/luajit-root/usr/local/openresty/luajit/lib -L/home/ubuntu/RMTP/openresty-1.13.6.2/build/luajit-root/usr/local/openresty/luajit/lib -Wl,-rpath,/usr/local/openresty/luajit/lib -Wl,-E -Wl,-E -ldl -lpthread -lcrypt -L/home/ubuntu/RMTP/openresty-1.13.6.2/build/luajit-root/usr/local/openresty/luajit/lib -lluajit-5.1 -lm -ldl -L/home/ubuntu/RMTP/openresty-1.13.6.2/build/luajit-root/usr/local/openresty/luajit/lib -lluajit-5.1 -lm -ldl -lpcre -lssl -lcrypto -ldl -lz \-Wl,-Esed -e "s|%%PREFIX%%|/usr/local/openresty/nginx|" \ -e "s|%%PID_PATH%%|/usr/local/openresty/nginx/logs/nginx.pid|" \ -e "s|%%CONF_PATH%%|/usr/local/openresty/nginx/conf/nginx.conf|" \ -e "s|%%ERROR_LOG_PATH%%|/usr/local/openresty/nginx/logs/error.log|" \ &lt; docs/man/nginx.8 &gt; objs/nginx.8make[2]: Leaving directory '/home/ubuntu/RMTP/openresty-1.13.6.2/build/nginx-1.13.6'make[1]: Leaving directory '/home/ubuntu/RMTP/openresty-1.13.6.2/build/nginx-1.13.6'//编译安装root@VM-53-84-ubuntu:/home/ubuntu/RMTP/openresty-1.13.6.2# make install || mkdir -p '/usr/local/openresty/nginx/logs'test -d '/usr/local/openresty/nginx/html' \ || cp -R docs/html '/usr/local/openresty/nginx'test -d '/usr/local/openresty/nginx/logs' \ || mkdir -p '/usr/local/openresty/nginx/logs'make[2]: Leaving directory '/home/ubuntu/RMTP/openresty-1.13.6.2/build/nginx-1.13.6'make[1]: Leaving directory '/home/ubuntu/RMTP/openresty-1.13.6.2/build/nginx-1.13.6'mkdir -p /usr/local/openresty/site/lualib /usr/local/openresty/site/pod /usr/local/openresty/site/manifestln -sf /usr/local/openresty/nginx/sbin/nginx /usr/local/openresty/bin/openresty//为了方便，软链接nginxroot@VM-53-84-ubuntu:/home/ubuntu/RMTP/openresty-1.13.6.2# ln -s /usr/local/openresty/nginx/sbin/nginx /usr/sbin/nginx//启动root@VM-53-84-ubuntu:/home/ubuntu/RMTP/openresty-1.13.6.2# nginx//验证是否启动成功root@VM-53-84-ubuntu:/home/ubuntu/RMTP/openresty-1.13.6.2# curl 111.231.243.184&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to OpenResty!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to OpenResty!&lt;/h1&gt;&lt;p&gt;If you see this page, the OpenResty web platform is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href="https://openresty.org/"&gt;openresty.org&lt;/a&gt;.&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for flying OpenResty.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 下载安装nginx的RMTP模块nginx-rtmp-module12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061root@VM-53-84-ubuntu:/home/ubuntu/RMTP/openresty-1.13.6.2# nginx -s stoproot@VM-53-84-ubuntu:/home/ubuntu/RMTP/openresty-1.13.6.2# ./configure --add-module=/home/ubuntu/RTTMP/nginx-rtmp-module-masterplatform: linux (linux)cp -rp bundle/ buildcd buildcd LuaJIT-2.1-20180420INFO: found -msse4.2 in cc.make TARGET_STRIP=@: CCDEBUG=-g XCFLAGS='-DLUAJIT_ENABLE_LUA52COMPAT -msse4.2' CC=cc PREFIX=/usr/local/openresty/luajit==== Building LuaJIT 2.1.0-beta3 ====make -C srcmake[1]: Entering directory '/home/ubuntu/RMTP/openresty-1.13.6.2/build/LuaJIT-2.1-20180420/src'HOSTCC host/minilua.oHOSTLINK host/miniluaDYNASM host/buildvm_arch.hHOSTCC host/buildvm.oHOSTCC host/buildvm_asm.ochecking for OpenSSL library ... foundchecking for zlib library ... foundcreating objs/Makefile//省略一部分输出。。。。。Configuration summary + using system PCRE library + using system OpenSSL library + using system zlib library nginx path prefix: "/usr/local/openresty/nginx" nginx binary file: "/usr/local/openresty/nginx/sbin/nginx" nginx modules path: "/usr/local/openresty/nginx/modules" nginx configuration prefix: "/usr/local/openresty/nginx/conf" nginx configuration file: "/usr/local/openresty/nginx/conf/nginx.conf" nginx pid file: "/usr/local/openresty/nginx/logs/nginx.pid" nginx error log file: "/usr/local/openresty/nginx/logs/error.log" nginx http access log file: "/usr/local/openresty/nginx/logs/access.log" nginx http client request body temporary files: "client_body_temp" nginx http proxy temporary files: "proxy_temp" nginx http fastcgi temporary files: "fastcgi_temp" nginx http uwsgi temporary files: "uwsgi_temp" nginx http scgi temporary files: "scgi_temp"cd ../..Type the following commands to build and install: make make installroot@VM-53-47-ubuntu:/home/ubuntu/RMTP/openresty-1.13.6.2# make//省略一部分输出。。。。。objs/addon/dash/ngx_rtmp_mp4.o \objs/addon/nginx-rtmp-module-master/ngx_rtmp_stat_module.o \objs/addon/nginx-rtmp-module-master/ngx_rtmp_control_module.o \objs/ngx_modules.o \-L/home/ubuntu/RMTP/openresty-1.13.6.2/build/luajit-root/usr/local/openresty/luajit/lib -L/home/ubuntu/RMTP/openresty-1.13.6.2/build/luajit-root/usr/local/openresty/luajit/lib -Wl,-rpath,/usr/local/openresty/luajit/lib -Wl,-E -Wl,-E -ldl -lpthread -lcrypt -L/home/ubuntu/RMTP/openresty-1.13.6.2/build/luajit-root/usr/local/openresty/luajit/lib -lluajit-5.1 -lm -ldl -L/home/ubuntu/RMTP/openresty-1.13.6.2/build/luajit-root/usr/local/openresty/luajit/lib -lluajit-5.1 -lm -ldl -lpcre -lssl -lcrypto -ldl -lz \-Wl,-Esed -e "s|%%PREFIX%%|/usr/local/openresty/nginx|" \ -e "s|%%PID_PATH%%|/usr/local/openresty/nginx/logs/nginx.pid|" \ -e "s|%%CONF_PATH%%|/usr/local/openresty/nginx/conf/nginx.conf|" \ -e "s|%%ERROR_LOG_PATH%%|/usr/local/openresty/nginx/logs/error.log|" \ &lt; docs/man/nginx.8 &gt; objs/nginx.8make[2]: Leaving directory '/home/ubuntu/RMTP/openresty-1.13.6.2/build/nginx-1.13.6'make[1]: Leaving directory '/home/ubuntu/RMTP/openresty-1.13.6.2/build/nginx-1.13.6'//拷贝新生成的nginx文件到OpenResty安装目录下root@VM-53-47-ubuntu:/home/ubuntu/RMTP/openresty-1.13.6.2# cp build/nginx-1.13.6/objs/nginx /usr/local/openresty/nginx/sbin 接着修改nginx.conf配置文件，修改后的nginx.conf配置文件如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164root@ubuntu:/home/kaithmy/RTMP# cat /usr/local/openresty/nginx/conf/nginx.conf#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; use epoll;# 选择epoll模型可以达到最佳的IO性能 worker_connections 1024;&#125;rtmp &#123; #RTMP服务 server &#123; listen 1935; #//服务端口 chunk_size 4096; #//数据传输块的大小 application vod &#123; play /opt/video; #//视频文件存放位置。 &#125; application rtmplive &#123; live on; #为 rtmp 引擎设置最大连接数。默认为 off max_connections 1024; &#125; application live&#123; #直播 live on; hls on; #这个参数把直播服务器改造成实时回放服务器。 wait_key on; #对视频切片进行保护，这样就不会产生马赛克了。 hls_path /opt/video/hls; #切片视频文件存放位置。 hls_fragment 600s; #设置HLS片段长度。 hls_playlist_length 10m; #设置HLS播放列表长度，这里设置的是10分钟。 hls_continuous on; #连续模式。 hls_cleanup on; #对多余的切片进行删除。 hls_nested on; #嵌套模式。 &#125; &#125;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location /stat &#123; rtmp_stat all; rtmp_stat_stylesheet stat.xsl; &#125; location /stat.xsl &#123; root /home/kaithmy/RTMP/nginx-rtmp-module-master/; &#125; location / &#123; root html; index index.html index.htm; &#125; location /live &#123; #这里也是需要添加的字段。 types &#123; application/vnd.apple.mpegurl m3u8; video/mp2t ts; &#125; alias /opt/video/hls; expires -1; add_header Cache-Control no-cache; add_header Access-Control-Allow-Origin *; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 测试 首先测试推流服务 启动nginx后，我们往服务器的/opt/video目录下上传一个flv视频，如我上传的是01a.flv,接着我们使用potplayer打开我们的推流地址rtmp://119.29.162.191:1935/vod/01a.flv,接着我们就可以观看我们上传的视频了 接着测试直播功能 测试直播功能需要用到OBS Studio，一款非常好用的软件，我们在软件的设置里设置好我们的推流地址，如我的是rtmp://119.29.162.191/live，点击开始推流后就可以开始直播了，其他人则可以通过地址http://119.29.162.191/live/index.m3u8观看我们的直播 由于开启了回放，所以直播的会被缓存下来，并且以分片形式存放，具体参数与配置参考nginx.conf 参考： https://blog.52itstyle.com/archives/2254/ https://blog.52itstyle.com/archives/1764/]]></content>
      <categories>
        <category>RMTP</category>
      </categories>
      <tags>
        <tag>RMTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 内存泄漏]]></title>
    <url>%2F2018%2F01%2F30%2FAndroid-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[Android内存泄漏是一个经常要遇到的问题，程序在内存泄漏的时候很容易导致OOM的发生。那么如何查找内存泄漏和避免内存泄漏就是需要知晓的一个问题，首先我们需要知道一些基础知识。 Java的四种引用强引用: 强引用是Java中最普通的引用，随意创建一个对象然后在其他的地方引用一下，就是强引用，强引用的对象Java宁愿OOM也不会回收他 软引用: 软引用是比强引用弱的引用，在Java gc的时候，如果软引用所引用的对象被回收，首次gc失败的话会继而回收软引用的对象，软引用适合做缓存处理 可以和引用队列（ReferenceQueue）一起使用，当对象被回收之后保存他的软引用会放入引用队列 弱引用: 弱引用是比软引用更加弱的引用，当Java执行gc的时候，如果弱引用所引用的对象被回收，无论他有没有用都会回收掉弱引用的对象，不过gc是一个比较低优先级的线程，不会那么及时的回收掉你的对象。 可以和引用队列一起使用，当对象被回收之后保存他的弱引用会放入引用队列 虚引用: 虚引用和没有引用是一样的，他必须和引用队列一起使用，当Java回收一个对象的时候，如果发现他有虚引用，会在回收对象之前将他的虚引用加入到与之关联的引用队列中。 可以通过这个特性在一个对象被回收之前采取措施 下面是一个例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;(); String sw = "虚引用"; switch (sw) &#123; case "软引用": Object objSoft = new Object(); SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(objSoft, referenceQueue); System.out.println("GC前获取:" + softReference.get()); objSoft = null; System.gc(); Thread.sleep(1000); System.out.println("GC后获取:" + softReference.get()); System.out.println("队列中的结果:" + referenceQueue.poll()); break; /* * GC前获取:java.lang.Object@61bbe9ba * GC后获取:java.lang.Object@61bbe9ba * 队列中的结果:null * */ case "弱引用": Object objWeak = new Object(); WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(objWeak, referenceQueue); System.out.println("GC前获取:" + weakReference.get()); objWeak = null; System.gc(); Thread.sleep(1000); System.out.println("GC后获取:" + weakReference.get()); System.out.println("队列中的结果:" + referenceQueue.poll()); /* * GC前获取:java.lang.Object@61bbe9ba * GC后获取:null * 队列中的结果:java.lang.ref.WeakReference@610455d6 * */ break; case "虚引用": Object objPhan = new Object(); PhantomReference&lt;Object&gt; phantomReference = new PhantomReference&lt;&gt;(objPhan, referenceQueue); System.out.println("GC前获取:" + phantomReference.get()); objPhan = null; System.gc(); //此处的区别是当objPhan的内存被gc回收之前虚引用就会被加入到ReferenceQueue队列中，其他的引用都为当引用被gc掉时候，引用会加入到ReferenceQueue中 Thread.sleep(1000); System.out.println("GC后获取:" + phantomReference.get()); System.out.println("队列中的结果:" + referenceQueue.poll()); /* * GC前获取:java.lang.Object@61bbe9ba * GC后获取:null * 队列中的结果:java.lang.ref.WeakReference@610455d6 * */ break; &#125; &#125;&#125; Java GC(参考JVM系列文章)目前oracle jdk和open jdk的虚拟机都为Hotspot，android 为Dalvik和Art 曾经的GC算法：引用计数简短的说引用计数就是对每一个对象的引用计算数字，如果引用就+1，不引用就-1，回收掉引用计数为0的对象。来达到垃圾回收 弊端：如果两个对象都应该被回收但是他俩却互相依赖，那么他两者的引用永远都不会为0，那么就永远无法回收， 无法解决循环引用的问题 这个算法只在很少数的虚拟机中使用过 现代的GC算法标记回收算法（Mark and Sweep GC） :从”GC Roots”集合开始，将内存整个遍历一次，保留所有可以被GC Roots直接或间接引用到的对象，而剩下的对象都当作垃圾对待并回收，这个算法需要中断进程内其它组件的执行并且可能产生内存碎片。复制算法（Copying） :将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。标记-压缩算法（Mark-Compact） :先需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。分代 :将所有的新建对象都放入称为年轻代的内存区域，年轻代的特点是对象会很快回收，因此，在年轻代就选择效率较高的复制算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老生代的内存空间。对于新生代适用于复制算法，而对于老年代则采取标记-压缩算法。 导致内存泄漏的原因对象在GC Root中可达，也就是他的引用不为空，所以GC无法回收它也就会导致内存泄漏 GC Root起点 虚拟机栈中引用的对象方法区中类静态属性引用的对象方法区中常量引用的对象JNI引用的对象GC可以续一秒当一个对象在引用链中失S#x53BB;了引用，那么他就真的要告别世界了吗，其实并不是，虚拟机会给他“缓刑”，每一个对象有一个finalize() 方法，虚拟机是否给他缓刑取决于这个对象的这个方法是否被执行，如果这个对象的这个方法没有被覆盖或者这个方法被执行过一次，那么就要“行刑”了。真的是“续一秒” 如果这个对象的finalize()方法应该被执行，那么虚拟机会将它放在F-Queue队列中，稍后虚拟机会自动创建一个Finalizer线程去执行这个队列中的对象的这个方法。如果对象在finalize()中成功自救，举个例子，把自己和一个存在的对象强引用，那么就不会被回收，否则就真的被回收了。 但是虚拟机并不会保证Finalizer线程执行结束再进行回收，因为如果在某一个对象的finalize()方法中执行了死循环或者超级耗时的操作，虚拟机等待这个执行结束的话就会导致整个Gc崩溃了 首先注意这个方法只能被执行一次，第二次就会标记了这个方法被执行过不会再执行了，其次，这个方法不一定会被执行到，所以不要依赖finalize()去自救。这不是好的做法。 并发GC和非并发GCAndroid2.3之后支持了并发的GC。 非并发GC : 虚拟机在执行GC的时候进行Stop the world，也就是挂起其他所有的线程，通常会持续上百毫秒，一次Mark，然后直接清理 并发GC : 跟非并发的简单gc来比较，一般非并发GC需要耗费上百ms的时间来进行，而并发gc仅仅需要10ms左右的时间，效率大幅度提升（数据来自：技术小黑屋大大），但是并发gc由于需要进行重复的处理改动的对象，所以需要更多的CPU资源 两者的差别： 首先非并发GC简单粗暴，直接挂起所有的线程，此时Java堆中肯定不会有任何的添加和修改，此时去递归GC树，然后标记-清理。但是这样会造成很大的开销，大家都等着你岂不是很没面子= = 然而非并发的GC是一点一点来的，跟线程同步进行这样就不会有很长时间的等待，但是你要明白一个道理，想把地扫干净这段时间必须没人来踩，所以他要有挂起线程的过程。 那么并发是怎么实现的呢？首先有个知识点就是Jvm在分配内存的时候，有两种方式 指针碰撞：一个指针，申请一块内存就指针挪动相应的距离，不会产生内存碎片，这要求内存是很规整的空闲列表：每次申请一块内存给需要的对象，然后有一个列表记录了哪些位置被申请了，下次申请的时候就不申请这个位置，这样适用于内存不是很规整的情况创建对象是一个频繁的操作，那么我们如何保证原子性呢？两种方案 CAS(Compare and Swap)策略配上失败重试来保证原子性每个线程分配一个TLAB : 很简单，每个线程自己有自己的一块内存，那么分配的时候自己锁自己的分区就行了，提高了效率我们用的是第二种 233 所以获取Java堆锁的时候，重点来了，我们逐个线程去锁TLAB，而不是一次全锁住，当然提高了并发GC的效率，所以更快。但是引来的问题就是并发的问题，所以下一步要重复去修改在一个个探索时候被改的对象。也就需要更多的CPU资源。 我们为什么要关注GC首先我们知道虚拟机如何去GC才能了解到如何让一个对象被正确的回收，这样才不能内存泄漏 其次无论是并发GC还是非并发GC都会导致挂起其他的所有线程，那么就会带来程序卡顿。 ART在GC上做到了更加细粒度的控制，可以更加流畅的GC 常见的内存泄漏案例:Handler内存泄漏首先铺垫一句话：非静态的内部类和匿名类会隐式的持有外部类的引用123456789101112131415161718192021public class MainActivity extends AppCompatActivity &#123; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; Log.d("smallSohoSolo", "Hello Handler"); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; Log.d("smallSohoSolo", "Running"); &#125; &#125;, 1000 * 60 * 10); //10分钟之后执行 finish(); &#125;&#125; 这段代码有很明显的内存泄漏，首先Handler和Runnable都是匿名内部类的实例，他们都会持有MainActivity的引用， Handler发送的消息到了消息队列中Activity被结束掉这个消息中包含了Handler的引用，Handler包含了Activity的引用，而且他还是个Runnable，也是匿名内部类，也间接包含了MainActivity引用在Main Lopper中，当此消息被取出来，这未执行的10分钟里面，MainActivity没法回收内存泄漏有人可能会说短暂的内存泄漏又能怎样？这是错误的想法，因为只要发生内存泄漏，在这段时间只要进行了大内存的操作（比如加载一个照片墙），就有风险因为这个内存泄漏造成OOM（占用内存肯定剩下的少了） 上面这个如何修改呢？ 将Runnable和Handler改成static 或者在外部定义内部使用。 其他常见的内存泄漏静态变量内存泄漏：使用静态变量来引用一个事物，在不使用之后没有下掉，那么引用存在就会一直泄漏单例导致的内存泄漏：使用的单例中保存了不应该被一直持有的对象，那么就会造成内存泄漏由第三方库使用不当导致的内存泄漏：比如EventBus，Activity销毁的时候没有反注册就会导致引用一直被持有无法回收还有很多。。。他们都是因为引用没有被清理造成的如何查看内存泄漏简单粗暴 —&gt; LeakCanary: Square出品的库，当出现内存泄漏的时候会出现 精打细算 —&gt; Android Studio 内存工具: 可以Dump下来当前的内存路径，然后分析出来哪些对象目前的状态。很强]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8系列之重新认识HashMap]]></title>
    <url>%2F2017%2F12%2F06%2FJava-8%E7%B3%BB%E5%88%97%E4%B9%8B%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HashMap%2F</url>
    <content type="text"><![CDATA[摘要HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。 简介Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示： ashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。 上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。 内部实现搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。 存储结构-字段从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？ 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。1234567891011121314static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用来定位数组索引位置 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个node Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125; public final K getKey()&#123; ... &#125; public final V getValue() &#123; ... &#125; public final String toString() &#123; ... &#125; public final int hashCode() &#123; ... &#125; public final V setValue(V newValue) &#123; ... &#125; public final boolean equals(Object o) &#123; ... &#125;&#125; Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。 HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码： 1map.put("美团","小美"); 系统将调用”美团”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。 如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。 在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下： 1234int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子int modCount; int size; 首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。 在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考http://blog.csdn.net/liuqiyao_01/article/details/14475159，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考http://blog.csdn.net/v_july_v/article/details/6105630。 功能实现-方法HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。 确定哈希桶数组索引位置不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):1234567891011方法一：static final int hash(Object key) &#123; //jdk1.8 &amp; jdk1.7 int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;方法二：static int indexFor(int h, int length) &#123; //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 return h &amp; (length-1); //第三步 取模运算&#125; 这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。 对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。 这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。 下面举例说明下，n为table的长度。 析HashMap的put方法HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； ②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； ③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； ④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； ⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； ⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 JDK1.8HashMap的put方法源码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 1 public V put(K key, V value) &#123; 2 // 对key的hashCode()做hash 3 return putVal(hash(key), key, value, false, true); 4 &#125; 5 6 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, 7 boolean evict) &#123; 8 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; 9 // 步骤①：tab为空则创建10 if ((tab = table) == null || (n = tab.length) == 0)11 n = (tab = resize()).length;12 // 步骤②：计算index，并对null做处理 13 if ((p = tab[i = (n - 1) &amp; hash]) == null) 14 tab[i] = newNode(hash, key, value, null);15 else &#123;16 Node&lt;K,V&gt; e; K k;17 // 步骤③：节点key存在，直接覆盖value18 if (p.hash == hash &amp;&amp;19 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))20 e = p;21 // 步骤④：判断该链为红黑树22 else if (p instanceof TreeNode)23 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);24 // 步骤⑤：该链为链表25 else &#123;26 for (int binCount = 0; ; ++binCount) &#123;27 if ((e = p.next) == null) &#123;28 p.next = newNode(hash, key,value,null); //链表长度大于8转换为红黑树进行处理29 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st 30 treeifyBin(tab, hash);31 break;32 &#125; // key已经存在直接覆盖value33 if (e.hash == hash &amp;&amp;34 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) 35 break;36 p = e;37 &#125;38 &#125;39 40 if (e != null) &#123; // existing mapping for key41 V oldValue = e.value;42 if (!onlyIfAbsent || oldValue == null)43 e.value = value;44 afterNodeAccess(e);45 return oldValue;46 &#125;47 &#125;48 ++modCount;49 // 步骤⑥：超过最大容量 就扩容50 if (++size &gt; threshold)51 resize();52 afterNodeInsertion(evict);53 return null;54 &#125; 扩容机制扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。 我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。12345678910111213 1 void resize(int newCapacity) &#123; //传入新的容量 2 Entry[] oldTable = table; //引用扩容前的Entry数组 3 int oldCapacity = oldTable.length; 4 if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 5 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 6 return; 7 &#125; 8 9 Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组10 transfer(newTable); //！！将数据转移到新的Entry数组里11 table = newTable; //HashMap的table属性引用新的Entry数组12 threshold = (int)(newCapacity * loadFactor);//修改阈值13 &#125; 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。1234567891011121314151617 1 void transfer(Entry[] newTable) &#123; 2 Entry[] src = table; //src引用了旧的Entry数组 3 int newCapacity = newTable.length; 4 for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 5 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 6 if (e != null) &#123; 7 src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） 8 do &#123; 9 Entry&lt;K,V&gt; next = e.next;10 int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置11 e.next = newTable[i]; //标记[1]12 newTable[i] = e; //将元素放在数组上13 e = next; //访问下一个Entry链上的元素14 &#125; while (e != null);15 &#125;16 &#125;17 &#125; newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 1 final Node&lt;K,V&gt;[] resize() &#123; 2 Node&lt;K,V&gt;[] oldTab = table; 3 int oldCap = (oldTab == null) ? 0 : oldTab.length; 4 int oldThr = threshold; 5 int newCap, newThr = 0; 6 if (oldCap &gt; 0) &#123; 7 // 超过最大值就不再扩充了，就只好随你碰撞去吧 8 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; 9 threshold = Integer.MAX_VALUE;10 return oldTab;11 &#125;12 // 没超过最大值，就扩充为原来的2倍13 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;14 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)15 newThr = oldThr &lt;&lt; 1; // double threshold16 &#125;17 else if (oldThr &gt; 0) // initial capacity was placed in threshold18 newCap = oldThr;19 else &#123; // zero initial threshold signifies using defaults20 newCap = DEFAULT_INITIAL_CAPACITY;21 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);22 &#125;23 // 计算新的resize上限24 if (newThr == 0) &#123;25 26 float ft = (float)newCap * loadFactor;27 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?28 (int)ft : Integer.MAX_VALUE);29 &#125;30 threshold = newThr;31 @SuppressWarnings(&#123;"rawtypes"，"unchecked"&#125;)32 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];33 table = newTab;34 if (oldTab != null) &#123;35 // 把每个bucket都移动到新的buckets中36 for (int j = 0; j &lt; oldCap; ++j) &#123;37 Node&lt;K,V&gt; e;38 if ((e = oldTab[j]) != null) &#123;39 oldTab[j] = null;40 if (e.next == null)41 newTab[e.hash &amp; (newCap - 1)] = e;42 else if (e instanceof TreeNode)43 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);44 else &#123; // 链表优化重hash的代码块45 Node&lt;K,V&gt; loHead = null, loTail = null;46 Node&lt;K,V&gt; hiHead = null, hiTail = null;47 Node&lt;K,V&gt; next;48 do &#123;49 next = e.next;50 // 原索引51 if ((e.hash &amp; oldCap) == 0) &#123;52 if (loTail == null)53 loHead = e;54 else55 loTail.next = e;56 loTail = e;57 &#125;58 // 原索引+oldCap59 else &#123;60 if (hiTail == null)61 hiHead = e;62 else63 hiTail.next = e;64 hiTail = e;65 &#125;66 &#125; while ((e = next) != null);67 // 原索引放到bucket里68 if (loTail != null) &#123;69 loTail.next = null;70 newTab[j] = loHead;71 &#125;72 // 原索引+oldCap放到bucket里73 if (hiTail != null) &#123;74 hiTail.next = null;75 newTab[j + oldCap] = hiHead;76 &#125;77 &#125;78 &#125;79 &#125;80 &#125;81 return newTab;82 &#125; 线程安全性在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：1234567891011121314151617181920public class HashMapInfiniteLoop &#123; private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2，0.75f); public static void main(String[] args) &#123; map.put(5， "C"); new Thread("Thread1") &#123; public void run() &#123; map.put(7, "B"); System.out.println(map); &#125;; &#125;.start(); new Thread("Thread2") &#123; public void run() &#123; map.put(3, "A); System.out.println(map); &#125;; &#125;.start(); &#125; &#125; 其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。 通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。 线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。 JDK1.8与JDK1.7的性能对比HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。 Hash较均匀的情况为了便于测试，我们先写一个类Key，如下：123456789101112131415161718192021222324252627class Key implements Comparable&lt;Key&gt; &#123; private final int value; Key(int value) &#123; this.value = value; &#125; @Override public int compareTo(Key o) &#123; return Integer.compare(this.value, o.value); &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Key key = (Key) o; return value == key.value; &#125; @Override public int hashCode() &#123; return value; &#125;&#125; 这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下：123456789101112131415public class Keys &#123; public static final int MAX_KEY = 10_000_000; private static final Key[] KEYS_CACHE = new Key[MAX_KEY]; static &#123; for (int i = 0; i &lt; MAX_KEY; ++i) &#123; KEYS_CACHE[i] = new Key(i); &#125; &#125; public static Key of(int value) &#123; return KEYS_CACHE[value]; &#125;&#125; 现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下：1234567891011121314151617181920static void test(int mapSize) &#123; HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key,Integer&gt;(mapSize); for (int i = 0; i &lt; mapSize; ++i) &#123; map.put(Keys.of(i), i); &#125; long beginTime = System.nanoTime(); //获取纳秒 for (int i = 0; i &lt; mapSize; i++) &#123; map.get(Keys.of(i)); &#125; long endTime = System.nanoTime(); System.out.println(endTime - beginTime); &#125; public static void main(String[] args) &#123; for(int i=10;i&lt;= 1000 0000;i*= 10)&#123; test(i); &#125; &#125; 在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下：通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。 Hash极不均匀的情况假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：123456789class Key implements Comparable&lt;Key&gt; &#123; //... @Override public int hashCode() &#123; return 1; &#125;&#125; 仍然执行main方法，得出的结果如下表所示：从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。 测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。 小结 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。 HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。 JDK1.8引入红黑树大程度优化了HashMap的性能。 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。 参考 JDK1.7&amp;JDK1.8 源码。 CSDN博客频道，HashMap多线程死循环问题，2014。 红黑联盟，Java类集框架之HashMap(JDK1.8)源码剖析，2015。 CSDN博客频道， 教你初步了解红黑树，2010。 Java Code Geeks，HashMap performance improvements in Java 8，2014。 Importnew，危险！在HashMap中将可变对象用作Key，2014。 CSDN博客频道，为什么一般hashtable的桶数会取一个素数，2013。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm(10):JVM演讲PPT分享]]></title>
    <url>%2F2017%2F10%2F29%2Fjvm-10-JVM%E6%BC%94%E8%AE%B2PPT%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[JVM PPT的演进文稿分享 此PPT长达46页，不方便在页面中全部展示，文中只展示了文稿的前十二页。 获取完整版请在公众号内回复“JVM”。 或者点击如下链接：https://faithlove.github.io/file/JVM体系结构与GC调优.pptx]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm(9):如何优化Java GC「译」]]></title>
    <url>%2F2017%2F10%2F29%2Fjvm-9-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96Java-GC%E3%80%8C%E8%AF%91%E3%80%8D%2F</url>
    <content type="text"><![CDATA[本文由CrowHawk翻译，地址：如何优化Java GC「译」，是Java GC调优的经典佳作。 Sangmin Lee发表在Cubrid上的”Become a Java GC Expert”系列文章的第三篇《How to Tune Java Garbage Collection》,本文的作者是韩国人，写在JDK 1.8发布之前，虽然有些地方有些许过时，但整体内容还是非常有价值的。译者此前也看到有人翻译了本文，发现其中有许多错漏生硬和语焉不详之处，因此决定自己翻译一份，供大家分享。 本文是“成为Java GC专家”系列文章的第三篇，在系列的第一篇文章《理解Java GC》中，我们了解到了不同GC算法的执行过程、GC的工作原理、新生代和老年代的概念、JDK 7中你需要了解的5种GC类型以及每一种GC对性能的影响。 在系列的第二篇文章《如何监控Java GC》中笔者已经解释了JVM进行实时GC的原理、监控GC的方法以及可以使这一过程更加迅速高效的工具。 在第三篇文章中，笔者将基于实际生产环境中的案例，介绍几个GC优化的最佳参数设置。在此我们假设你已经理解了本系列前两篇文章的内容，因此为了更深入的理解本文所讲内容，我建议你在阅读本篇文章之前先仔细阅读这两篇文章。 GC优化是必要的吗？或者更准确地说，GC优化对Java基础服务来说是必要的吗？答案是否定的，事实上GC优化对Java基础服务来说在有些场合是可以省去的，但前提是这些正在运行的Java系统，必须包含以下参数或行为： 内存大小已经通过-Xms和-Xmx参数指定过 运行在server模式下（使用-server参数） 系统中没有残留超时日志之类的错误日志 换句话说，如果你在运行时没有手动设置内存大小并且打印出了过多的超时日志，那你就需要对系统进行GC优化。 不过你需要时刻谨记一句话：GC tuning is the last task to be done. 现在来想一想GC优化的最根本原因，垃圾收集器的工作就是清除Java创建的对象，垃圾收集器需要清理的对象数量以及要执行的GC数量均取决于已创建的对象数量。因此，为了使你的系统在GC上表现良好，首先需要减少创建对象的数量。 俗话说“冰冻三尺非一日之寒”，我们在编码时要首先要把下面这些小细节做好，否则一些琐碎的不良代码累积起来将让GC的工作变得繁重而难于管理： 使用StringBuilder或StringBuffer来代替String 尽量少输出日志 尽管如此，仍然会有我们束手无策的情况。XML和JSON解析过程往往占用了最多的内存，即使我们已经尽可能地少用String、少输出日志，仍然会有大量的临时内存（大约10-100MB）被用来解析XML或JSON文件，但我们又很难弃用XML和JSON。在此，你只需要知道这一过程会占据大量内存即可。 如果在经过几次重复的优化后应用程序的内存用量情况有所改善，那么久可以启动GC优化了。 笔者总结了GC优化的两个目的： 将进入老年代的对象数量降到最低 减少Full GC的执行时间 将进入老年代的对象数量降到最低除了可以在JDK 7及更高版本中使用的G1收集器以外，其他分代GC都是由Oracle JVM提供的。关于分代GC，就是对象在Eden区被创建，随后被转移到Survivor区，在此之后剩余的对象会被转入老年代。也有一些对象由于占用内存过大，在Eden区被创建后会直接被传入老年代。老年代GC相对来说会比新生代GC更耗时，因此，减少进入老年代的对象数量可以显著降低Full GC的频率。你可能会以为减少进入老年代的对象数量意味着把它们留在新生代，事实正好相反，新生代内存的大小是可以调节的。 降低Full GC的时间Full GC的执行时间比Minor GC要长很多，因此，如果在Full GC上花费过多的时间（超过1s），将可能出现超时错误。 如果通过减小老年代内存来减少Full GC时间，可能会引起OutOfMemoryError或者导致Full GC的频率升高。 另外，如果通过增加老年代内存来降低Full GC的频率，Full GC的时间可能因此增加。 因此，你需要把老年代的大小设置成一个“合适”的值。 影响GC性能的参数正如我在系列的第一篇文章《理解Java GC》末尾提到的，不要幻想着“如果有人用他设置的GC参数获取了不错的性能，我们为什么不复制他的参数设置呢？”，因为对于不用的Web服务，它们创建的对象大小和生命周期都不相同。 举一个简单的例子，如果一个任务的执行条件是A，B，C，D和E，另一个完全相同的任务执行条件只有A和B，那么哪一个任务执行速度更快呢？作为常识来讲，答案很明显是后者。 Java GC参数的设置也是这个道理，设置好几个参数并不会提升GC执行的速度，反而会使它变得更慢。GC优化的基本原则是将不同的GC参数应用到两个及以上的服务器上然后比较它们的性能，然后将那些被证明可以提高性能或减少GC执行时间的参数应用于最终的工作服务器上。 下面这张表展示了与内存大小相关且会影响GC性能的GC参数 表1：GC优化需要考虑的JVM参数 类型 参数 描述 堆内存大小 -Xms 启动JVM时堆内存的大小 -Xmx 堆内存最大限制 新生代空间大小 -XX:NewRatio 新生代和老年代的内存比 -XX:NewSize 新生代内存大小 -XX:SurvivorRatio Eden区和Survivor区的内存比 笔者在进行GC优化时最常用的参数是-Xms,-Xmx和-XX:NewRatio。-Xms和-Xmx参数通常是必须的，所以NewRatio的值将对GC性能产生重要的影响。 有些人可能会问如何设置永久代内存大小，你可以用-XX:PermSize和-XX:MaxPermSize参数来进行设置，但是要记住，只有当出现OutOfMemoryError错误时你才需要去设置永久代内存。 还有一个会影响GC性能的因素是垃圾收集器的类型,下表展示了关于GC类型的可选参数（基于JDK 6.0）： 表2：GC类型可选参数 GC类型 参数 备注 Serial GC -XX:+UseSerialGC Parallel GC -XX:+UseParallelGC-XX:ParallelGCThreads=value Parallel Compacting GC -XX:+UseParallelOldGC CMS GC -XX:+UseConcMarkSweepGC-XX:+UseParNewGC-XX:+CMSParallelRemarkEnabled-XX:CMSInitiatingOccupancyFraction=value-XX:+UseCMSInitiatingOccupancyOnly G1 -XX:+UnlockExperimentalVMOptions-XX:+UseG1GC 在JDK 6中这两个参数必须配合使用 除了G1收集器外，可以通过设置上表中每种类型第一行的参数来切换GC类型，最常见的非侵入式GC就是Serial GC，它针对客户端系统进行了特别的优化。 会影响GC性能的参数还有很多，但是上述的参数会带来最显著的效果，请切记，设置太多的参数并不一定会提升GC的性能。 GC优化的过程GC优化的过程和大多数常见的提升性能的过程相似，下面是笔者使用的流程： 1.监控GC状态你需要监控GC从而检查系统中运行的GC的各种状态，具体方法请查看系列的第二篇文章《如何监控Java GC》 2.分析监控结果后决定是否需要优化GC在检查GC状态后，你需要分析监控结构并决定是否需要进行GC优化。如果分析结果显示运行GC的时间只有0.1-0.3秒，那么就不需要把时间浪费在GC优化上，但如果运行GC的时间达到1-3秒，甚至大于10秒，那么GC优化将是很有必要的。 但是，如果你已经分配了大约10GB内存给Java，并且这些内存无法省下，那么就无法进行GC优化了。在进行GC优化之前，你需要考虑为什么你需要分配这么大的内存空间，如果你分配了1GB或2GB大小的内存并且出现了OutOfMemoryError，那你就应该执行堆转储（heap dump）来消除导致异常的原因。 注意： 堆转储（heap dump）是一个用来检查Java内存中的对象和数据的内存文件。该文件可以通过执行JDK中的jmap命令来创建。在创建文件的过程中，所有Java程序都将暂停，因此，不要再系统执行过程中创建该文件。 你可以在互联网上搜索heap dump的详细说明。对于韩国读者，可以直接参考我去年发布的书：《The story of troubleshooting for Java developers and system operators》 (Sangmin Lee, Hanbit Media, 2011, 416 pages) 3.设置GC类型/内存大小如果你决定要进行GC优化，那么你需要选择一个GC类型并且为它设置内存大小。此时如果你有多个服务器，请如上文提到的那样，在每台机器上设置不同的GC参数并分析它们的区别。 4.分析结果在设置完GC参数后就可以开始收集数据，请在收集至少24小时后再进行结果分析。如果你足够幸运，你可能会找到系统的最佳GC参数。如若不然，你还需要分析输出日志并检查分配的内存，然后需要通过不断调整GC类型/内存大小来找到系统的最佳参数。 5.如果结果令人满意，将参数应用到所有服务器上并结束GC优化如果GC优化的结果令人满意，就可以将参数应用到所有服务器上，并停止GC优化。 在下面的章节中，你将会看到上述每一步所做的具体工作。 监控GC状态并分析结果在运行中的Web应用服务器（Web Application Server,WAS）上查看GC状态的最佳方式就是使用jstat命令。笔者在《如何监控Java GC》中已经介绍过了jstat命令，所以在本篇文章中我将着重关注数据部分。 下面的例子展示了某个还没有执行GC优化的JVM的状态（虽然它并不是运行服务器）。 1234$ jstat -gcutil 21719 1sS0 S1 E O P YGC YGCT FGC FGCT GCT48.66 0.00 48.10 49.70 77.45 3428 172.623 3 59.050 231.67348.66 0.00 48.10 49.70 77.45 3428 172.623 3 59.050 231.673 我们先看一下YGC（从应用程序启动到采样时发生 Young GC 的次数）和YGCT（从应用程序启动到采样时 Young GC 所用的时间(秒)），计算YGCT/YGC会得出，平均每次新生代的GC耗时50ms，这是一个很小的数字，通过这个结果可以看出，我们大可不必关注新生代GC对GC性能的影响。 现在来看一下FGC（ 从应用程序启动到采样时发生 Full GC 的次数）和FGCT（从应用程序启动到采样时 Full GC 所用的时间(秒)），计算FGCT/FGC会得出，平均每次老年代的GC耗时19.68s。有可能是执行了三次Full GC，每次耗时19.68s，也有可能是有两次只花了1s,另一次花了58s。不管是哪一种情况，GC优化都是很有必要的。 使用jstat命令可以很容易地查看GC状态，但是分析GC的最佳方式是加上-verbosegc参数来生成日志。在之前的文章中笔者已经解释了如何分析这些日志。HPJMeter是笔者最喜欢的用于分析-verbosegc生成的日志的工具，它简单易用，使用HPJmeter可以很容易地查看GC执行时间以及GC发生频率。 此外，如果GC执行时间满足下列所有条件，就没有必要进行GC优化了： Minor GC执行非常迅速（50ms以内） Minor GC没有频繁执行（大约10s执行一次） Full GC执行非常迅速（1s以内） Full GC没有频繁执行（大约10min执行一次） 括号中的数字并不是绝对的，它们也随着服务的状态而变化。有些服务可能要求一次Full GC在0.9s以内，而有些则会放得更宽一些。因此，对于不同的服务，需要按照不同的标准考虑是否需要执行GC优化。 当检查GC状态时，不能只查看Minor GC和Full GC的时间，还必须要关注GC执行的次数。如果新生代空间太小，Minor GC将会非常频繁地执行（有时每秒会执行一次，甚至更多）。此外，传入老年代的对象数目会上升，从而导致Full GC的频率升高。因此，在执行jstat命令时，请使用-gccapacity参数来查看具体占用了多少空间。 设置GC类型/内存大小设置GC类型Oracle JVM有5种垃圾收集器，但是在JDK 7以前的版本中，你只能在Parallel GC, Parallel Compacting GC 和CMS GC之中选择，至于具体选择哪个，则没有具体的原则和规则。 既然这样的话，我们如何来选择GC呢？最好的方法是把三种都用上，但是有一点必须明确——CMS GC通常比其他并行（Parallel）GC都要快（这是因为CMS GC是并发的GC），如果确实如此，那只选择CMS GC就可以了，不过CMS GC也不总是更快，当出现concurrent mode failure时，CMS GC就会比并行GC更慢了。 Concurrent mode failure 现在让我们来深入地了解一下concurrent mode failure。 并行GC和CMS GC的最大区别是并行GC采用“标记-整理”(Mark-Compact)算法而CMS GC采用“标记-清除”(Mark-Sweep)算法（具体内容可参照译者的文章《GC算法与内存分配策略》）,compact步骤就是通过移动内存来消除内存碎片，从而消除分配的内存之间的空白区域。 对于并行GC来说，无论何时执行Full GC，都会进行compact工作，这消耗了太多的时间。不过在执行完Full GC后，下次内存分配将会变得更快（因为直接顺序分配相邻的内存）。 相反，CMS GC没有compact的过程，因此CMS GC运行的速度更快。但是也是由于没有整理内存，在进行磁盘清理之前，内存中会有很多零碎的空白区域，这也导致没有足够的空间分配给大对象。例如，在老年代还有300MB可用空间，但是连一个10MB的对象都没有办法被顺序存储在老年代中，在这种情况下，会报出“concurrent mode failure”的warning，然后系统执行compact操作。但是CMS GC在这种情况下执行的compact操作耗时要比并行GC高很多，并且这还会导致另一个问题，关于“concurrent mode failure”的详细说明，可用参考Oracle工程师撰写的《Understanding CMS GC Logs》。 综上所述，你需要根据你的系统情况为其选择一个最适合的GC类型。 每个系统都有最适合它的GC类型等着你去寻找，如果你有6台服务器，我建议你每两个服务器设置相同的参数，然后加上-verbosegc参数再分析结果。 设置内存大小下面展示了内存大小、GC运行次数和GC运行时间之间的关系： 大内存空间 减少了GC的次数 提高了GC的运行时间 小内存空间 增多了GC的次数 降低了GC的运行时间 关于如何设置内存的大小，没有一个标准答案，如果服务器资源充足并且Full GC能在1s内完成，把内存设为10GB也是可以的，但是大部分服务器并不处在这种状态中，当内存设为10GB时，Full GC会耗时10-30s,具体的时间自然与对象的大小有关。 既然如此，我们该如何设置内存大小呢？通常我推荐设为500MB，这不是说你要通过-Xms500m和-Xmx500m参数来设置WAS内存。根据GC优化之前的状态，如果Full GC后还剩余300MB的空间，那么把内存设为1GB是一个不错的选择（300MB（默认程序占用）+ 500MB（老年代最小空间）+200MB（空闲内存））。这意味着你需要为老年代设置至少500MB空间，因此如果你有三个运行服务器，可以把它们的内存分别设置为1GB，1.5GB，2GB，然后检查结果。 理论上来说，GC执行速度应该遵循1GB&gt; 1.5GB&gt; 2GB，1GB内存时GC执行速度最快。然而，理论上的1GB内存Full GC消耗1s、2GB内存Full GC消耗2 s在现实里是无法保证的，实际的运行时间还依赖于服务器的性能和对象大小。因此，最好的方法是创建尽可能多的测量数据并监控它们。 在设置内存空间大小时，你还需要设置一个参数：NewRatio。NewRatio的值是新生代和老年代空间大小的比例。如果XX:NewRatio=1，则新生代空间:老年代空间=1:1，如果堆内存为1GB，则新生代:老年代=500MB:500MB。如果NewRatio等于2，则新生代:老年代=1:2，因此，NewRatio的值设置得越大，则老年代空间越大，新生代空间越小。 你可能会认为把NewRatio设为1会是最好的选择，然而事实并非如此，根据笔者的经验，当NewRatio设为2或3时，整个GC的状态表现得更好。 完成GC优化最快地方法是什么？答案是比较性能测试的结果。为了给每台服务器设置不同的参数并监控它们，最好查看的是一或两天后的数据。当通过性能测试来进行GC优化时，你需要在不同的测试时保证它们有相同的负载和运行环境。然而，即使是专业的性能测试人员，想精确地控制负载也很困难，并且需要大量的时间准备。因此，更加方便容易的方式是直接设置参数来运行，然后等待运行的结果（即使这需要消耗更多的时间）。 分析GC优化的结果在设置了GC参数和-verbosegc参数后，可以使用tail命令确保日志被正确地生成。如果参数设置得不正确或日志未生成，那你的时间就被白白浪费了。如果日志收集没有问题的话，在收集一或两天数据后再检查结果。最简单的方法是把日志从服务器移到你的本地PC上，然后用HPJMeter分析数据。 在分析结果时，请关注下列几点（这个优先级是笔者根据自己的经验拟定的，我认为选取GC参数时应考虑的最重要的因素是Full GC的运行时间。）： 单次Full GC运行时间 单次Minor GC运行时间 Full GC运行间隔 Minor GC运行间隔 整个Full GC的时间 整个Minor GC的运行时间 整个GC的运行时间 Full GC的执行次数 Minor GC的执行次数 找到最佳的GC参数是件非常幸运的，然而在大多数时候，我们并不会如此幸运，在进行GC优化时一定要小心谨慎，因为当你试图一次完成所有的优化工作时，可能会出现OutOfMemoryError错误。 优化案例到目前为止，我们一直在从理论上介绍GC优化，现在是时候将这些理论付诸实践了，我们将通过几个例子来更深入地理解GC优化。 示例1下面这个例子是针对Service S的优化，对于最近刚开发出来的Service S，执行Full GC需要消耗过多的时间。 现在看一下执行jstat -gcutil的结果 12S0 S1 E O P YGC YGCT FGC FGCT GCT12.16 0.00 5.18 63.78 20.32 54 2.047 5 6.946 8.993 左边的Perm区的值对于最初的GC优化并不重要，而YGC参数的值更加对于这次优化更为重要。 平均执行一次Minor GC和Full GC消耗的时间如下表所示： 表3：Service S的Minor GC 和Full GC的平均执行时间 GC类型 GC执行次数 GC执行时间 平均值 Minor GC 54 2.047s 37ms Full GC 5 6.946s 1.389s 37ms对于Minor GC来说还不赖，但1.389s对于Full GC来说意味着当GC发生在数据库Timeout设置为1s的系统中时，可能会频繁出现超时现象。 首先，你需要检查开始GC优化前内存的使用情况。使用jstat -gccapacity命令可以检查内存用量情况。在笔者的服务器上查看到的结果如下： 12NGCMN NGCMX NGC S0C S1C EC OGCMN OGCMX OGC OC PGCMN PGCMX PGC PC YGC FGC212992.0 212992.0 212992.0 21248.0 21248.0 170496.0 1884160.0 1884160.0 1884160.0 1884160.0 262144.0 262144.0 262144.0 262144.0 54 5 其中的关键值如下： 新生代内存用量：212,992 KB 老年代内存用量：1,884,160 KB 因此，除了永久代以外，被分配的内存空间加起来有2GB，并且新生代：老年代=1：9，为了得到比使用jstat更细致的结果，还需加上-verbosegc参数获取日志，并把三台服务器按照如下方式设置（除此以外没有使用任何其他参数）： NewRatio=2 NewRatio=3 NewRatio=4 一天后我得到了系统的GC log，幸运的是，在设置完NewRatio后系统没有发生任何Full GC。 这是为什么呢？这是因为大部分对象在创建后很快就被回收了，所有这些对象没有被传入老年代，而是在新生代就被销毁回收了。 在这样的情况下，就没有必要去改变其他的参数值了，只要选择一个最合适的NewRatio值即可。那么，如何确定最佳的NewRatio值呢？为此，我们分析一下每种NewRatio值下Minor GC的平均响应时间。 在每种参数下Minor GC的平均响应时间如下： NewRatio=2：45ms NewRatio=3：34ms NewRatio=4：30ms 我们可以根据GC时间的长短得出NewRatio=4是最佳的参数值（尽管NewRatio=4时新生代空间是最小的）。在设置完GC参数后，服务器没有发生Full GC。 为了说明这个问题，下面是服务执行一段时间后执行jstat –gcutil的结果: 12S0 S1 E O P YGC YGCT FGC FGCT GCT8.61 0.00 30.67 24.62 22.38 2424 30.219 0 0.000 30.219 你可能会认为是服务器接收的请求少才使得GC发生的频率较低，实际上，虽然Full GC没有执行过，但Minor GC被执行了2424次。 示例2这是一个Service A的例子。我们通过公司内部的应用性能管理系统（APM）发现JVM暂停了相当长的时间（超过8秒），因此我们进行了GC优化。我们努力寻找JVM暂停的原因，后来发现是因为Full GC执行时间过长，因此我们决定进行GC优化。 在GC优化的开始阶段，我们加上了-verbosegc参数，结果如下图所示： 图1：进行GC优化之前STW的时间 上图是由HPJMeter生成的图片之一。横坐标表示JVM执行的时间，纵坐标表示每次GC的时间。CMS为绿点，表示Full GC的结果，而Parallel Scavenge为蓝点，表示Minor GC的结果。 之前我说过CMS GC是最快的GC，但是上面的结果显示在一些时候CMS耗时达到了15s。是什么导致了这一结果？请记住我之前说的：CMS在执行compact（整理）操作时会显著变慢。此外，服务的内存通过-Xms1g和=Xmx4g设置了，而分配的内存只有4GB。 因此笔者将GC类型从CMS GC改为了Parallel GC，把内存大小设为2GB，并把NewRatio设为3。在执行jstat -gcutil几小时后的结果如下： 12S0 S1 E O P YGC YGCT FGC FGCT GCT0.00 30.48 3.31 26.54 37.01 226 11.131 4 11.758 22.890 Full GC的时间缩短了，变成了每次3s，跟15s比有了显著提升。但是3s依然不够快，为此笔者创建了以下6种情况： Case 1: -XX:+UseParallelGC -Xms1536m -Xmx1536m -XX:NewRatio=2 Case 2: -XX:+UseParallelGC -Xms1536m -Xmx1536m -XX:NewRatio=3 Case 3: -XX:+UseParallelGC -Xms1g -Xmx1g -XX:NewRatio=3 Case 4: -XX:+UseParallelOldGC -Xms1536m -Xmx1536m -XX:NewRatio=2 Case 5: -XX:+UseParallelOldGC -Xms1536m -Xmx1536m -XX:NewRatio=3 Case 6: -XX:+UseParallelOldGC -Xms1g -Xmx1g -XX:NewRatio=3 上面哪一种情况最快？结果显示，内存空间越小，运行结果最少。下图展示了性能最好的Case 6的结果图，它的最慢响应时间只有1.7s，并且响应时间的平均值已经被控制到了1s以内。 图2：Case 6的持续时间图 基于上图的结果，按照Case 6调整了GC参数，但这却导致每晚都会发生OutOfMemoryError。很难解释发生异常的具体原因，简单地说，应该是批处理程序导致了内存泄漏，我们正在解决相关的问题。 如果只对GC日志做一些短时间的分析就将相关参数部署到所有服务器上来执行GC优化，这将是非常危险的。切记，只有当你同时仔细分析服务的执行情况和GC日志后，才能保证GC优化没有错误地执行。 在上文中，我们通过两个GC优化的例子来说明了GC优化是怎样执行的。正如上文中提到的，例子中设置的GC参数可以设置在相同的服务器之上，但前提是他们具有相同的CPU、操作系统、JDK版本并且运行着相同的服务。此外，不要把我使用的参数照搬到你的应用上，它们可能在你的机器上并不能起到同样良好的效果。 总结笔者没有执行heap dump并分析内存的详细内容，而是通过自己的经验进行GC优化。精确地分析内存可以得到更好的优化效果，不过这种分析一般只适用于内存使用量相对固定的场景。如果服务严重过载并占有了大量的内存，则建议你根据之前的经验进行GC优化。 笔者已经在一些服务上设置了G1 GC参数并进行了性能测试，但还没有应用于正式的生产环境。G1 GC的速度快于任何其他的GC类型，但是你必须要升级到JDK 7。此外，暂时还无法保证它的稳定性，没有人知道运行时是否会出现致命的错误，因此G1GC暂时还不适合投入应用。 等未来JDK 7真正稳定了（这并不是说它现在不稳定），并且WAS针对JDK 7进行优化后，G1 GC最终能按照预期的那样来工作，等到那一天我们可能就不再需要GC优化了。 想了解关于GC优化的更多细节，请前往Slideshare.com 查看相关资料。强烈推荐Everything I Ever Learned About JVM Performance Tuning @Twitter,作者是Attila Szegedi, 一名Twitter工程师，请花些时间好好阅读它。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm(8):jvm知识点总览]]></title>
    <url>%2F2017%2F10%2F27%2Fjvm-8-jvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E8%A7%88%2F</url>
    <content type="text"><![CDATA[在江湖中要练就绝世武功必须内外兼备，精妙的招式和深厚的内功，武功的基础是内功。对于武功低（就像江南七怪）的人，招式更重要，因为他们不能靠内功直接去伤人，只能靠招式，利刃上优势来取胜了，但是练到高手之后，内功就更主要了。一个内功低的人招式在奇妙也打不过一个内功高的人。比如，你剑法再厉害，一剑刺过来，别人一掌打断你的剑，你还怎么使剑法，你一掌打到一个武功高的人身上，那人没什么事，却把你震伤了，你还怎么打。同样两者也是相辅相成的，内功深厚之后，原来普通的一招一式威力也会倍增。 对于搞开发的我们其实也是一样，现在流行的框架越来越多，封装的也越来越完善，各种框架可以搞定一切，几乎不用关注底层的实现，初级程序员只要熟悉基本的使用方法，便可以快速的开发上线；但对于高级程序员来讲，内功的修炼却越发的重要，比如算法、设计模式、底层原理等，只有把这些基础熟练之后，才能在开发过程中知其然知其所以然，出现问题时能快速定位到问题的本质。 对于Java程序员来讲，spring全家桶几乎可以搞定一切，spring全家桶便是精妙的招式，jvm就是内功心法很重要的一块，线上出现性能问题，jvm调优更是不可回避的问题。因此JVM基础知识对于高级程序员的重要性不必言语，我司在面试高级开发的时候，jvm相关知识也必定是考核的标准之一。本篇文章会根据之前写的jvm系列文章梳理出jvm需要关注的所有考察点。 jvm 总体梳理jvm体系总体分四大块： 类的加载机制 jvm内存结构 GC算法 垃圾回收 GC分析 命令调优 当然这些知识点在之前的文章中都有详细的介绍，这里只做主干的梳理 这里画了一个思维导图，将所有的知识点进行了陈列，因为图比较大可以点击右键下载了放大查看。 公众号内回复：”jvm”,可查看大图。 类的加载机制主要关注点： 什么是类的加载 类的生命周期 类加载器 双亲委派模型 什么是类的加载 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 类的生命周期 类的生命周期包括这几个部分，加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程,如下图； 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象 连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用 初始化，为类的静态变量赋予正确的初始值 使用，new出对象程序中使用 卸载，执行垃圾回收 几个小问题？ 1、JVM初始化步骤 ？ 2、类初始化时机 ？3、哪几种情况下，Java虚拟机将结束生命周期？ 答案参考这篇文章jvm系列(一):java类的加载机制 类加载器 启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。 应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器 类加载机制 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 jvm内存结构主要关注点： jvm内存结构都是什么 对象分配规则 jvm内存结构 方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序计数器是运行是线程私有的内存区域。 Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。 JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。 对象分配规则 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。 如何通过参数来控制个各个内存区域参考此文章：jvm系列(二):JVM内存结构 GC算法 垃圾回收主要关注点： 对象存活判断 GC算法 垃圾回收器 对象存活判断 判断对象是否存活一般有两种方式： 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。 GC算法 GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。 标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。 复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存 分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。 垃圾回收器 Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。 ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。 Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。 Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法 CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。 G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征 GC算法和垃圾回收器算法图解以及更详细内容参考 jvm系列(三):GC算法 垃圾收集器 GC分析 命令调优主要关注点： GC日志分析 调优命令 调优工具 GC日志分析 摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）： 2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs] 2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs] 通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数 Young GC日志: Full GC日志: 调优命令 Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 jmap，JVM Memory Map命令用于生成heap dump文件 jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看 jstack，用于生成java虚拟机当前时刻的线程快照。 jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。 详细的命令使用参考这里jvm系列(四):jvm调优-命令篇 调优工具 常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。 jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控 jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。 MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗 GChisto，一款专业分析gc日志的工具 工具使用参考 jvm系列(七):jvm调优-工具篇 作者：纯洁的微笑出处：http://www.ityouknow.com/版权归作者所有]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm(7):jvm调优-工具篇]]></title>
    <url>%2F2017%2F10%2F27%2Fjvm-7-jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87%2F</url>
    <content type="text"><![CDATA[16年的时候花了一些时间整理了一些关于jvm的介绍文章,到现在回顾起来还是一些还没有补充全面，其中就包括如何利用工具来监控调优前后的性能变化。工具做为图形化界面来展示更能直观的发现问题，另一方面一些耗费性能的分析（dump文件分析）一般也不会在生产直接分析，往往dump下来的文件达1G左右，人工分析效率较低，因此利用工具来分析jvm相关问题，长长可以到达事半功倍的效果来。 jvm监控分析工具一般分为两类，一种是jdk自带的工具，一种是第三方的分析工具。jdk自带工具一般在jdk bin目录下面，以exe的形式直接点击就可以使用，其中包含分析工具已经很强大，几乎涉及了方方面面，但是我们最常使用的只有两款：jconsole.exe和jvisualvm.exe；第三方的分析工具有很多，各自的侧重点不同，比较有代表性的：MAT(Memory Analyzer Tool)、GChisto等。 对于大型 JAVA 应用程序来说，再精细的测试也难以堵住所有的漏洞，即便我们在测试阶段进行了大量卓有成效的工作，很多问题还是会在生产环境下暴露出来，并且很难在测试环境中进行重现。JVM 能够记录下问题发生时系统的部分运行状态，并将其存储在堆转储 (Heap Dump) 文件中，从而为我们分析和诊断问题提供了重要的依据。其中VisualVM和MAT是dump文件的分析利器。 jdk自带的工具jconsoleJconsole（Java Monitoring and Management Console）是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监测工具。jconsole使用jvm的扩展机制获取并展示虚拟机中运行的应用程序的性能和资源消耗等信息。 直接在jdk/bin目录下点击jconsole.exe即可启动，界面如下: 在弹出的框中可以选择本机的监控本机的java应用，也可以选择远程的java服务来监控，如果监控远程服务需要在tomcat启动脚本中添加如下代码： 123-Dcom.sun.management.jmxremote.port=6969 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false 连接进去之后，就可以看到jconsole概览图和主要的功能：概述、内存、线程、类、VM、MBeans 概述，以图表的方式显示出堆内存使用量，活动线程数，已加载的类，CUP占用率的折线图，可以非常清晰的观察在程序执行过程中的变动情况。 内存，主要展示了内存的使用情况，同时可以查看堆和非堆内存的变化值对比，也可以点击执行GC来处罚GC的执行 线程，主界面展示线程数的活动数和峰值，同时点击左下方线程可以查看线程的详细信息，比如线程的状态是什么，堆栈内容等，同时也可以点击“检测死锁”来检查线程之间是否有死锁的情况。 类，主要展示已加载类的相关信息。 VM 概要，展示JVM所有信息总览，包括基本信息、线程相关、堆相关、操作系统、VM参数等。 Mbean,查看Mbean的属性，方法等。 VisualVM简介 VisualVM 是一个工具，它提供了一个可视界面，用于查看 Java 虚拟机 (Java Virtual Machine, JVM) 上运行的基于 Java 技术的应用程序（Java 应用程序）的详细信息。VisualVM 对 Java Development Kit (JDK) 工具所检索的 JVM 软件相关数据进行组织，并通过一种使您可以快速查看有关多个 Java 应用程序的数据的方式提供该信息。您可以查看本地应用程序以及远程主机上运行的应用程序的相关数据。此外，还可以捕获有关 JVM 软件实例的数据，并将该数据保存到本地系统，以供后期查看或与其他用户共享。 VisualVM 是javajdk自带的最牛逼的调优工具了吧，也是我平时使用最多调优工具，几乎涉及了jvm调优的方方面面。同样是在jdk/bin目录下面双击jvisualvm.exe既可使用，启动起来后和jconsole 一样同样可以选择本地和远程，如果需要监控远程同样需要配置相关参数，主界面如下； VisualVM可以根据需要安装不同的插件，每个插件的关注点都不同，有的主要监控GC，有的主要监控内存，有的监控线程等。 如何安装： 1、从主菜单中选择“工具”&gt;“插件”。2、在“可用插件”标签中，选中该插件的“安装”复选框。单击“安装”。3、逐步完成插件安装程序。 我这里以 Eclipse(pid 22296)为例，双击后直接展开，主界面展示了系统和jvm两大块内容，点击右下方jvm参数和系统属性可以参考详细的参数信息. 因为VisualVM的插件太多，我这里主要介绍三个我主要使用几个：监控、线程、Visual GC 监控的主页其实也就是，cpu、内存、类、线程的图表 线程和jconsole功能没有太大的区别 Visual GC 是常常使用的一个功能，可以明显的看到年轻代、老年代的内存变化，以及gc频率、gc的时间等。 以上的功能其实jconsole几乎也有，VisualVM更全面更直观一些，另外VisualVM非常多的其它功能，可以分析dump的内存快照，dump出来的线程快照并且进行分析等，还有其它很多的插件大家可以去探索 第三方调优工具MATMAT是什么？ MAT(Memory Analyzer Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。 通常内存泄露分析被认为是一件很有难度的工作，一般由团队中的资深人士进行。不过要介绍的 MAT（Eclipse Memory Analyzer）被认为是一个“傻瓜式“的堆转储文件分析工具，你只需要轻轻点击一下鼠标就可以生成一个专业的分析报告。和其他内存泄露分析工具相比，MAT 的使用非常容易，基本可以实现一键到位，即使是新手也能够很快上手使用。 MAT以eclipse 插件的形式来安装，具体的安装过程就不在描述了，可以利用visualvm或者是 jmap命令生产堆文件，导入eclipse mat中生成分析报告： 生产这会报表的同时也会在dump文件的同级目录下生成三份（dump_Top_Consumers.zip、dump_Leak_Suspects.zip、dump_Top_Components.zip）分析结果的html文件，方便发送给相关同事来查看。 需要关注的是下面的Actions、Reports、Step by Step区域： Histogram：列出内存中的对象，对象的个数以及大小，支持正则表达式查找，也可以计算出该类所有对象的retained size Dominator Tree：列出最大的对象以及其依赖存活的Object （大小是以Retained Heap为标准排序的） Top Consumers ： 通过图形列出最大的object duplicate classes ：检测由多个类装载器加载的类 Leak Suspects ：内存泄漏分析 Top Components: 列出大于总堆数的百分之1的报表。 Component Report:分析对象属于同一个包或者被同一个类加载器加载 以上只是一个初级的介绍，mat还有更强大的使用，比如对比堆内存，在生产环境中往往为了定位问题，每隔几分钟dump出一下内存快照，随后在对比不同时间的堆内存的变化来发现问题。 GChistoGChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。虽然界面略显粗糙，但是功能还是不错的。 配置好本地的jdk环境之后，双击GChisto.jar,在弹出的输入框中点击 add 选择gc.log日志 GC Pause Stats:可以查看GC 的次数、GC的时间、GC的开销、最大GC时间和最小GC时间等，以及相应的柱状图 GC Pause Distribution:查看GC停顿的详细分布，x轴表示垃圾收集停顿时间，y轴表示是停顿次数。 GC Timeline：显示整个时间线上的垃圾收集 不过这款工具已经不再维护，不能识别最新jdk的日志文件。 gcviewerGCViewer也是一款分析小工具，用于可视化查看由Sun / Oracle, IBM, HP 和 BEA Java 虚拟机产生的垃圾收集器的日志，gcviewer个人感觉显示 的界面比较乱没有GChisto更专业一些。 GC Easy这是一个web工具,在线使用非常方便. 地址: http://gceasy.io 进入官网，讲打包好的zip或者gz为后缀的压缩包上传，过一会就会拿到分析结果。 推荐使用此工具进行gc分析。 前期jvm系类文章回顾: jvm系列(一):java类的加载机制 jvm系列(二):JVM内存结构 jvm系列(三):GC算法 垃圾收集器 jvm系列(四):jvm调优-命令篇 jvm系列(五):tomcat性能调优和性能监控（visualvm） jvm系列(六):jvm调优-从eclipse开始 作者：纯洁的微笑出处：http://www.ityouknow.com/版权归作者所有]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm(6):Java服务GC参数调优案例]]></title>
    <url>%2F2017%2F10%2F27%2Fjvm-6-Java%E6%9C%8D%E5%8A%A1GC%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[本文介绍了一次生产环境的JVM GC相关参数的调优过程，通过参数的调整避免了GC卡顿对JAVA服务成功率的影响。 这段时间在整理jvm系列的文章，无意中发现本文，作者思路清晰通过步步分析最终解决问题。我个人特别喜欢这种实战类的内容，经原作者的授权同意，将文章分享于此。原文链接：Java服务GC参数调优案例，下面为转载此文的内容，备注部分为本人添加，主要起到说明的作用。 背景以及遇到的问题我们的Java HTTP服务属于OLTP类型，对成功率和响应时间的要求比较高，在生产环境中出现偶现的成功率突然下降然后又自动恢复的情况，如图所示： JVM和GC相关的参数如下： 123456-Xmx22528m-Xms22528m-XX:NewRatio=2-XX:+UseConcMarkSweepGC-XX:+UseParNewGC-XX:+CMSParallelRemarkEnabled 总结来说，由于服务中大量使用了Cache，所以堆大小开到了22G。GC算法使用CMS（UseConcMarkSweepGC），开启了降低标记停顿（CMSParallelRemarkEnabled），设置年轻代为并行收集（UseParNewGC），年轻代和老年代的比例为1:2 （NewRatio＝2）. JVM GC日志相关的参数如下： 123456789-Xloggc:/data/gc.log-XX:GCLogFileSize=10M-XX:NumberOfGCLogFiles=10-XX:+UseGCLogFileRotation-XX:+PrintGCDateStamps-XX:+PrintGCTimeStamps-XX:+PrintGCDetails-XX:+DisableExplicitGC-verbose:gc 问题解决过程排除应用程序的内存使用问题首先使用jmap查看内存使用情况： 1jmap -histo:live PID 这个命令把程序中当前的对象按照个数和占用的空间排序以后打印出来。这里没有发现使用异常的对象。 排除Cache内容过多的问题如果Cache内容过多也会导致JVM老年代容易被用满导致频繁GC，因此调出GC日志进行查看，发现每次GC以后内存使用一般是从20G降低到5G左右，因此常驻内存的Cache不是导致GC长时间卡顿的根本原因。对于GC LOG的查看有多种方式，使用VisualVM比较直观，需要使用VisualGC： 从图中我们可以看到伊甸园和老年代的空间分配，由于整体内存是20G，设置 -XX:NewRatio=2 因此老年代是14G，伊甸园＋S0+S1=7G 调整GC时间点（成功率抖动问题加重）如果GC需要处理的内存量比较大，执行的时间也就比较长，STW （Stop the World）时间也就更长。按照这个思路调整CMS启动的时间点，希望提早GC，也就是让GC变得更加频繁但是期望每次执行的时间较少。添加了下面这两个参数： 12-XX:+UseCMSInitiatingOccupancyOnly-XX:CMSInitiatingOccupancyFraction=50 意思是说在Old区使用了50%的时候触发GC。实验后发现GC的频率有所增加，但是每次GC造成的陈功率降低现象并没有减弱，因此弃用这两个参数。 调整对象在年轻代内存中驻留的时间（效果不明显）如果能够降低老年代GC的频率也可以达到降低GC影响的目的，因此尝试让对象在年轻代内存中进行更长时间的驻留，提升这些对象在年轻代GC时候被销毁的概率。使用参数1234567891011121314151617181920212223242526272829303132333435363738&gt; 备注： &gt; 1、MaxTenuringThreshold 在1.5.0_05之前最大值可以设置为31 ，1.5.0_06以后最大值可以设置为15，超过15会被认为无限大。参考：[Never set GC parameter -XX:MaxTenuringThreshold greater than 15](https://sourcevirtues.com/2013/03/29/never-set-gc-parameter-maxtenuringthreshold-greater-than-15/) &gt; 2、提升年轻代GC被销毁的概率，只是调整这个参数效果不大，第二次age的值会重新计算，参考：[说说MaxTenuringThreshold这个参数](http://bluedavy.me/?p=70) ### CMS-Remark之前强制进行年轻代的GC首先补充一下CMS的相关知识，在CMS整个过程中有两个步骤是STW的，如图红色部分：![](https://faithlove.github.io/pic/2017/jvm/articlex_cms.png)CMS并非没有暂停，而是用两次短暂停来替代串行标记整理算法的长暂停，它的收集周期是这样：- 1、初始标记(CMS-initial-mark),从root对象开始标记存活的对象- 2、并发标记(CMS-concurrent-mark)- 3、重新标记(CMS-remark),暂停所有应用程序线程，重新标记并发标记阶段遗漏的对象（在并发标记阶段结束后对象状态的更新导致）- 4、并发清除(CMS-concurrent-sweep)- 5、并发重设状态等待下次CMS的触发(CMS-concurrent-reset)。通过GC日志和成功率下降的时间点进行比对发现并不是每一次老年代GC都会导致成功率的下降，但是从中发现了一个规律：![](https://faithlove.github.io/pic/2017/jvm/cms_gc1.png)前两次GC CMS-Remark过程在4s左右造成了成功率的下降，但是第三次GC并没有对成功率造成明显的影响,CMS-Remark只有0.18s。Java HTTP 服务是通过Nginx进行反向代理的，nginx设置的超时时间是3s，所以如果GC卡顿在3s以内就不会对成功率造成太大的影响。从GC日志中又发现一个信息：![](https://faithlove.github.io/pic/2017/jvm/cms_gc2.png)在文档和相关资料中没有找到蓝色部分的含义，猜测是remark处理的内存量，处理的越多就越慢。添加下面两个参数强制在remark阶段和FULL GC阶段之前先在进行一次年轻代的GC，这样需要进行处理的内存量就不会太多。&gt; 备注： &gt; 1、蓝色部分的含义：remark标记需要清理对象的容量。关于如何分析CMS日志，可以参考这篇文章：[了解 CMS 垃圾回收日志](http://ifeve.com/jvm-cms-log/) &gt; 2、FULL GC阶段之前先在进行一次年轻代的GC的意义是：Yong区对象引用了Old区的对象，如果在Old区进行清理之前不进行Yong区清理，就会导致Old区被yong区引用的对象无法释放。可以参考这篇文章：[假笨说-又抓了一个导致频繁GC的鬼--数组动态扩容](http://mp.weixin.qq.com/s/HKdpmmvJKq45QZdV4Q2cYQ) ``` sh-XX:+ScavengeBeforeFullGC -XX:+CMSScavengeBeforeRemark 调优以后效果很明显，下面是两台配置完全相同的服务器在同一时间段的成功率和响应时间监控图，第一个没有添加强制年轻代GC的参数。 结论1、在CMS-remark阶段需要对堆中所有的内存对象进行处理，如果在这个阶段之前强制执行一次年轻代的GC会大量减少remark需要处理的内存数量，进而降低JVM卡顿对成功率的影响。2、对于Java HTTP服务，JVM的卡顿时间应该小于HTTP客户端的调用超时时间，否则JVM卡顿会对成功率造成影响。 感谢匠心零度对文章内容进行深入的探讨，备注内容属于讨论后的结果 参考文献JVM调优：选择合适的GC collector （三）Understanding CMS GC LogsJava VM Options You Should Always Use in Production]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm(5):Java GC 分析]]></title>
    <url>%2F2017%2F10%2F27%2Fjvm-5-Java-GC-%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Java GC就是JVM记录仪，书画了JVM各个分区的表演。 什么是 Java GCJava GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。 在Java语言出现之前，就有GC机制的存在，如Lisp语言），Java GC机制已经日臻完善，几乎可以自动的为我们做绝大多数的事情。然而，如果我们从事较大型的应用软件开发，曾经出现过内存优化的需求，就必定要研究Java GC机制。 简单总结一下，Java GC就是通过GC收集器回收不在存活的对象，保证JVM更加高效的运转。如果不了解GC算法和垃圾回收器可以参考这篇文章：jvm系列(三):GC算法 垃圾收集器。 如何获取 Java GC日志一般情况可以通过两种方式来获取GC日志，一种是使用命令动态查看，一种是在容器中设置相关参数打印GC日志。 命令动态查看Java 自动的工具行命令，jstat可以用来动态监控JVM内存的使用，统计垃圾回收的各项信息。 比如常用命令，-gc``` 统计垃圾回收堆的行为12345``` sh$ jstat -gc 1262 S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT 26112.0 24064.0 6562.5 0.0 564224.0 76274.5 434176.0 388518.3 524288.0 42724.7 320 6.417 1 0.398 6.815 也可以设置间隔固定时间来打印： 1$ jstat -gc 1262 2000 20 这个命令意思就是每隔2000ms输出1262的gc情况，一共输出20次 更详细的内容参考这篇文章：jvm系列(四):jvm调优-命令篇 GC参数JVM的GC日志的主要参数包括如下几个： 输出GC日志 12345678910111213141516171819- ```-XX:+PrintGCDetails``` 输出GC的详细日志 - ```-XX:+PrintGCTimeStamps``` 输出GC的时间戳（以基准时间的形式） - ```-XX:+PrintGCDateStamps``` 输出GC的时间戳（以日期的形式，如 2017-09-04T21:53:59.234+0800） - ```-XX:+PrintHeapAtGC``` 在进行GC的前后打印出堆的信息 - ```-Xloggc:../logs/gc.log``` 日志文件的输出路径 在生产环境中，根据需要配置相应的参数来监控JVM运行情况。### Tomcat 设置示例我们经常在tomcat的启动参数中添加JVM相关参数，这里有一个典型的示例：``` shJAVA_OPTS=&quot;-server -Xms2000m -Xmx2000m -Xmn800m -XX:PermSize=64m -XX:MaxPermSize=256m -XX:SurvivorRatio=4-verbose:gc -Xloggc:$CATALINA_HOME/logs/gc.log -Djava.awt.headless=true -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Dsun.rmi.dgc.server.gcInterval=600000 -Dsun.rmi.dgc.client.gcInterval=600000-XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=15&quot; 根据上面的参数我们来做一下解析： -Xmx2000m -Xmn800m -XX:PermSize1234567891011121314151617181920212223242526272829Xms，即为jvm启动时得JVM初始堆大小,Xmx为jvm的最大堆大小，xmn为新生代的大小，permsize为永久代的初始大小，MaxPermSize为永久代的最大空间。- ```-XX:SurvivorRatio=4``` SurvivorRatio为新生代空间中的Eden区和救助空间Survivor区的大小比值，默认是8，则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10。调小这个参数将增大survivor区，让对象尽量在survitor区呆长一点，减少进入年老代的对象。去掉救助空间的想法是让大部分不能马上回收的数据尽快进入年老代，加快年老代的回收频率，减少年老代暴涨的可能性，这个是通过将-XX:SurvivorRatio 设置成比较大的值（比如65536)来做到。- ```-verbose:gc -Xloggc:$CATALINA_HOME/logs/gc.log``` 将虚拟机每次垃圾回收的信息写到日志文件中，文件名由file指定，文件格式是平文件，内容和-verbose:gc输出内容相同。- ```-Djava.awt.headless=true ``` Headless模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。- ```-XX:+PrintGCTimeStamps -XX:+PrintGCDetails``` 设置gc日志的格式- ```-Dsun.rmi.dgc.server.gcInterval=600000 -Dsun.rmi.dgc.client.gcInterval=600000 ``` 指定rmi调用时gc的时间间隔- ```-XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=15 ``` 采用并发gc方式，经过15次minor gc 后进入年老代## 如何分析GC日志摘录GC日志一部分Young GC回收日志:``` sh2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs] Full GC回收日志: 12016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs] 通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数 通过两张图非常明显看出gc日志构成： Young GC日志: Full GC日志: GC分析工具GChistoGChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。虽然界面略显粗糙，但是功能还是不错的。 配置好本地的jdk环境之后，双击GChisto.jar,在弹出的输入框中点击 add 选择gc.log日志 GC Pause Stats:可以查看GC 的次数、GC的时间、GC的开销、最大GC时间和最小GC时间等，以及相应的柱状图 GC Pause Distribution:查看GC停顿的详细分布，x轴表示垃圾收集停顿时间，y轴表示是停顿次数。 GC Timeline：显示整个时间线上的垃圾收集 不过这款工具已经不再维护 GC Easy这是一个web工具,在线使用非常方便. 地址: http://gceasy.io 进入官网，讲打包好的zip或者gz为后缀的压缩包上传，过一会就会拿到分析结果。 推荐使用此工具进行gc分析。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm(4):jvm调优-命令篇]]></title>
    <url>%2F2017%2F10%2F27%2Fjvm-4-jvm%E8%B0%83%E4%BC%98-%E5%91%BD%E4%BB%A4%E7%AF%87%2F</url>
    <content type="text"><![CDATA[运用jvm自带的命令可以方便的在生产监控和打印堆栈的日志信息帮忙我们来定位问题！虽然jvm调优成熟的工具已经有很多：jconsole、大名鼎鼎的VisualVM，IBM的Memory Analyzer等等，但是在生产环境出现问题的时候，一方面工具的使用会有所限制，另一方面喜欢装X的我们，总喜欢在出现问题的时候在终端输入一些命令来解决。所有的工具几乎都是依赖于jdk的接口和底层的这些命令，研究这些命令的使用也让我们更能了解jvm构成和特性。 Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo下面做一一介绍 jpsJVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 命令格式1jps [options] [hostid] option参数 -l : 输出主类全名或jar路径 -q : 只输出LVMID -m : 输出JVM启动时传递给main()的参数 -v : 输出JVM启动时显示指定的JVM参数 其中[option]、[hostid]参数也可以不写。 示例1234$ jps -l -m 28920 org.apache.catalina.startup.Bootstrap start 11589 org.apache.catalina.startup.Bootstrap start 25816 sun.tools.jps.Jps -l -m jstatjstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 命令格式1jstat [option] LVMID [interval] [count] 参数 [option] : 操作参数 LVMID : 本地虚拟机进程ID [interval] : 连续输出的时间间隔 [count] : 连续输出的次数 option 参数总览 Option Displays… class class loader的行为统计。Statistics on the behavior of the class loader. compiler HotSpt JIT编译器行为统计。Statistics of the behavior of the HotSpot Just-in-Time compiler. gc 垃圾回收堆的行为统计。Statistics of the behavior of the garbage collected heap. gccapacity 各个垃圾回收代容量(young,old,perm)和他们相应的空间统计。Statistics of the capacities of the generations and their corresponding spaces. gcutil 垃圾回收统计概述。Summary of garbage collection statistics. gccause 垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因。Summary of garbage collection statistics (same as -gcutil), with the cause of the last and gcnew 新生代行为统计。Statistics of the behavior of the new generation. gcnewcapacity 新生代与其相应的内存空间的统计。Statistics of the sizes of the new generations and its corresponding spaces. gcold 年老代和永生代行为统计。Statistics of the behavior of the old and permanent generations. gcoldcapacity 年老代行为统计。Statistics of the sizes of the old generation. gcpermcapacity 永生代行为统计。Statistics of the sizes of the permanent generation. printcompilation HotSpot编译方法统计。HotSpot compilation method statistics. option 参数详解-class监视类装载、卸载数量、总空间以及耗费的时间 123$ jstat -class 11589 Loaded Bytes Unloaded Bytes Time 7035 14506.3 0 0.0 3.67 Loaded : 加载class的数量 Bytes : class字节大小 Unloaded : 未加载class的数量 Bytes : 未加载class的字节大小 Time : 加载时间 -compiler输出JIT编译过的方法数量耗时等 123$ jstat -compiler 1262Compiled Failed Invalid Time FailedType FailedMethod 2573 1 0 47.60 1 org/apache/catalina/loader/WebappClassLoader findResourceInternal Compiled : 编译数量 Failed : 编译失败数量 Invalid : 无效数量 Time : 编译耗时 FailedType : 失败类型 FailedMethod : 失败方法的全限定名 -gc垃圾回收堆的行为统计，常用命令 123$ jstat -gc 1262 S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT 26112.0 24064.0 6562.5 0.0 564224.0 76274.5 434176.0 388518.3 524288.0 42724.7 320 6.417 1 0.398 6.815 C即Capacity 总容量，U即Used 已使用的容量 S0C : survivor0区的总容量 S1C : survivor1区的总容量 S0U : survivor0区已使用的容量 S1U : survivor1区已使用的容量 EC : Eden区的总容量 EU : Eden区已使用的容量 OC : Old区的总容量 OU : Old区已使用的容量 PC 当前perm的容量 (KB) PU perm的使用 (KB) YGC : 新生代垃圾回收次数 YGCT : 新生代垃圾回收时间 FGC : 老年代垃圾回收次数 FGCT : 老年代垃圾回收时间 GCT : 垃圾回收总消耗时间 1$ jstat -gc 1262 2000 20 这个命令意思就是每隔2000ms输出1262的gc情况，一共输出20次 -gccapacity同-gc，不过还会输出Java堆各区域使用到的最大、最小空间 123$ jstat -gccapacity 1262 NGCMN NGCMX NGC S0C S1C EC OGCMN OGCMX OGC OC PGCMN PGCMX PGC PC YGC FGC 614400.0 614400.0 614400.0 26112.0 24064.0 564224.0 434176.0 434176.0 434176.0 434176.0 524288.0 1048576.0 524288.0 524288.0 320 1 NGCMN : 新生代占用的最小空间 NGCMX : 新生代占用的最大空间 OGCMN : 老年代占用的最小空间 OGCMX : 老年代占用的最大空间 OGC：当前年老代的容量 (KB) OC：当前年老代的空间 (KB) PGCMN : perm占用的最小空间 PGCMX : perm占用的最大空间 -gcutil同-gc，不过输出的是已使用空间占总空间的百分比 123$ jstat -gcutil 28920 S0 S1 E O P YGC YGCT FGC FGCT GCT 12.45 0.00 33.85 0.00 4.44 4 0.242 0 0.000 0.242 -gccause垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因 123$ jstat -gccause 28920 S0 S1 E O P YGC YGCT FGC FGCT GCT LGCC GCC 12.45 0.00 33.85 0.00 4.44 4 0.242 0 0.000 0.242 Allocation Failure No GC LGCC：最近垃圾回收的原因 GCC：当前垃圾回收的原因 -gcnew统计新生代的行为 123$ jstat -gcnew 28920 S0C S1C S0U S1U TT MTT DSS EC EU YGC YGCT 419392.0 419392.0 52231.8 0.0 6 6 209696.0 3355520.0 1172246.0 4 0.242 TT：Tenuring threshold(提升阈值) MTT：最大的tenuring threshold DSS：survivor区域大小 (KB) -gcnewcapacity新生代与其相应的内存空间的统计 123$ jstat -gcnewcapacity 28920 NGCMN NGCMX NGC S0CMX S0C S1CMX S1C ECMX EC YGC FGC 4194304.0 4194304.0 4194304.0 419392.0 419392.0 419392.0 419392.0 3355520.0 3355520.0 4 0 NGC:当前年轻代的容量 (KB) S0CMX:最大的S0空间 (KB) S0C:当前S0空间 (KB) ECMX:最大eden空间 (KB) EC:当前eden空间 (KB) -gcold统计旧生代的行为 123$ jstat -gcold 28920 PC PU OC OU YGC FGC FGCT GCT 1048576.0 46561.7 6291456.0 0.0 4 0 0.000 0.242 -gcoldcapacity统计旧生代的大小和空间 123$ jstat -gcoldcapacity 28920 OGCMN OGCMX OGC OC YGC FGC FGCT GCT 6291456.0 6291456.0 6291456.0 6291456.0 4 0 0.000 0.242 -gcpermcapacity永生代行为统计 123$ jstat -gcpermcapacity 28920 PGCMN PGCMX PGC PC YGC FGC FGCT GCT 1048576.0 2097152.0 1048576.0 1048576.0 4 0 0.000 0.242 -printcompilationhotspot编译方法统计 123$ jstat -printcompilation 28920 Compiled Size Type Method 1291 78 1 java/util/ArrayList indexOf Compiled：被执行的编译任务的数量 Size：方法字节码的字节数 Type：编译类型 Method：编译方法的类名和方法名。类名使用”/“ 代替 “.” 作为空间分隔符. 方法名是给出类的方法名. 格式是一致于HotSpot - XX:+PrintComplation 选项 jmapjmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。 命令格式1jmap [option] LVMID option参数 dump : 生成堆转储快照 finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象 heap : 显示Java堆详细信息 histo : 显示堆中对象的统计信息 permstat : to print permanent generation statistics F : 当-dump没有响应时，强制生成dump快照 示例-dump常用格式 1-dump::live,format=b,file=&lt;filename&gt; pid dump堆到文件,format指定输出格式，live指明是活着的对象,file指定文件名 123$ jmap -dump:live,format=b,file=dump.hprof 28920 Dumping heap to /home/xxx/dump.hprof ... Heap dump file created dump.hprof这个后缀是为了后续可以直接用MAT(Memory Anlysis Tool)打开。 -finalizerinfo打印等待回收对象的信息 123456$ jmap -finalizerinfo 28920 Attaching to process ID 28920, please wait... Debugger attached successfully. Server compiler detected. JVM version is 24.71-b01 Number of objects pending for finalization: 0 可以看到当前F-QUEUE队列中并没有等待Finalizer线程执行finalizer方法的对象。 -heap打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$ jmap -heap 28920 Attaching to process ID 28920, please wait... Debugger attached successfully. Server compiler detected. JVM version is 24.71-b01 using thread-local object allocation. Parallel GC with 4 thread(s)//GC 方式 Heap Configuration: //堆内存初始化配置 MinHeapFreeRatio = 0 //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40) MaxHeapFreeRatio = 100 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70) MaxHeapSize = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小 NewSize = 1310720 (1.25MB)//对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小 MaxNewSize = 17592186044415 MB//对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小 OldSize = 5439488 (5.1875MB)//对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小 NewRatio = 2 //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率 SurvivorRatio = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 PermSize = 21757952 (20.75MB) //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小 MaxPermSize = 85983232 (82.0MB)//对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小 G1HeapRegionSize = 0 (0.0MB) Heap Usage://堆内存使用情况 PS Young Generation Eden Space://Eden区内存分布 capacity = 33030144 (31.5MB)//Eden区总容量 used = 1524040 (1.4534378051757812MB) //Eden区已使用 free = 31506104 (30.04656219482422MB) //Eden区剩余容量 4.614088270399305% used //Eden区使用比率 From Space: //其中一个Survivor区的内存分布 capacity = 5242880 (5.0MB) used = 0 (0.0MB) free = 5242880 (5.0MB) 0.0% used To Space: //另一个Survivor区的内存分布 capacity = 5242880 (5.0MB) used = 0 (0.0MB) free = 5242880 (5.0MB) 0.0% used PS Old Generation //当前的Old区内存分布 capacity = 86507520 (82.5MB) used = 0 (0.0MB) free = 86507520 (82.5MB) 0.0% used PS Perm Generation//当前的 “永生代” 内存分布 capacity = 22020096 (21.0MB) used = 2496528 (2.3808746337890625MB) free = 19523568 (18.619125366210938MB) 11.337498256138392% used 670 interned Strings occupying 43720 bytes. 可以很清楚的看到Java堆中各个区域目前的情况。 -histo打印堆的对象统计，包括对象数、内存大小等等 （因为在dump:live前会进行full gc，如果带上live则只统计活对象，因此不加live的堆大小要大于加live堆的大小 ） 1234567891011121314$ jmap -histo:live 28920 | more num #instances #bytes class name---------------------------------------------- 1: 83613 12012248 &lt;constMethodKlass&gt; 2: 23868 11450280 [B 3: 83613 10716064 &lt;methodKlass&gt; 4: 76287 10412128 [C 5: 8227 9021176 &lt;constantPoolKlass&gt; 6: 8227 5830256 &lt;instanceKlassKlass&gt; 7: 7031 5156480 &lt;constantPoolCacheKlass&gt; 8: 73627 1767048 java.lang.String 9: 2260 1348848 &lt;methodDataKlass&gt; 10: 8856 849296 java.lang.Class .... 仅仅打印了前10行 class name```是对象类型，说明如下：1234567891011``` xmlB byteC charD doubleF floatI intJ longZ boolean[ 数组，如[I表示int[][L+类名 其他对象 -permstat打印Java堆内存的永久保存区域的类加载器的智能统计信息。对于每个类加载器而言，它的名称、活跃度、地址、父类加载器、它所加载的类的数量和大小都会被打印。此外，包含的字符串数量和大小也会被打印。 123456789101112131415$ jmap -permstat 28920 Attaching to process ID 28920, please wait... Debugger attached successfully. Server compiler detected. JVM version is 24.71-b01 finding class loader instances ..done. computing per loader stat ..done. please wait.. computing liveness.liveness analysis may be inaccurate ... class_loader classes bytes parent_loader alive? type &lt;bootstrap&gt; 3111 18154296 null live &lt;internal&gt; 0x0000000600905cf8 1 1888 0x0000000600087f08 dead sun/reflect/DelegatingClassLoader@0x00000007800500a0 0x00000006008fcb48 1 1888 0x0000000600087f08 dead sun/reflect/DelegatingClassLoader@0x00000007800500a0 0x00000006016db798 0 0 0x00000006008d3fc0 dead java/util/ResourceBundle$RBClassLoader@0x0000000780626ec0 0x00000006008d6810 1 3056 null dead sun/reflect/DelegatingClassLoader@0x00000007800500a0 -F强制模式。如果指定的pid没有响应，请使用jmap -dump或jmap -histo选项。此模式下，不支持live子选项。 jhatjhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。 命令格式1jhat [dumpfile] 参数 -stack false|true关闭对象分配调用栈跟踪(tracking object allocation call stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.&gt; -refs false|true关闭对象引用跟踪(tracking of references to objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。&gt; -port port-number设置 jhat HTTP server 的端口号. 默认值 7000.&gt; -exclude exclude-file指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。&gt; -baseline exclude-file指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as not being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用.&gt; -debug int设置 debug 级别. 0 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.&gt; -version启动后只显示版本信息就退出&gt; -J&lt; flag &gt;因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 512 MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx. 示例12345678910$ jhat -J-Xmx512m dump.hprof eading from dump.hprof... Dump file created Fri Mar 11 17:13:42 CST 2016 Snapshot read, resolving... Resolving 271678 objects... Chasing references, expect 54 dots...................................................... Eliminating duplicate references...................................................... Snapshot resolved. Started HTTP server on port 7000 Server is ready. 中间的-J-Xmx512m是在dump快照很大的情况下分配512M内存去启动HTTP服务器，运行完之后就可在浏览器打开Http://localhost:7000进行快照分析堆快照分析主要在最后面的Heap Histogram里，里面根据class列出了dump的时候所有存活对象。 分析同样一个dump快照，MAT需要的额外内存比jhat要小的多的多，所以建议使用MAT来进行分析，当然也看个人偏好。 分析打开浏览器Http://localhost:7000，该页面提供了几个查询功能可供使用： 1234567All classes including platformShow all members of the rootsetShow instance counts for all classes (including platform)Show instance counts for all classes (excluding platform)Show heap histogramShow finalizer summaryExecute Object Query Language (OQL) query 一般查看堆异常情况主要看这个两个部分：Show instance counts for all classes (excluding platform)，平台外的所有对象信息。如下图： Show heap histogram 以树状图形式展示堆情况。如下图： 具体排查时需要结合代码，观察是否大量应该被回收的对象在一直被引用或者是否有占用内存特别大的对象无法被回收。一般情况，会down到客户端用工具来分析 jstackjstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。 命令格式1jstack [option] LVMID option参数 -F : 当正常输出请求不被响应时，强制输出线程堆栈 -l : 除堆栈外，显示关于锁的附加信息 -m : 如果调用到本地方法的话，可以显示C/C++的堆栈 示例12345678910111213141516171819202122232425262728$ jstack -l 11494|more2016-07-28 13:40:04Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.71-b01 mixed mode):"Attach Listener" daemon prio=10 tid=0x00007febb0002000 nid=0x6b6f waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None"http-bio-8005-exec-2" daemon prio=10 tid=0x00007feb94028000 nid=0x7b8c waiting on condition [0x00007fea8f56e000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for &lt;0x00000000cae09b80&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043) at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32) at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1068) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) Locked ownable synchronizers: - None ..... 分析这里有一篇文章解释的很好分析打印出的文件内容 jinfojinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令 命令格式1jinfo [option] [args] LVMID option参数 -flag : 输出指定args参数的值 -flags : 不需要args参数，输出所有JVM参数的值 -sysprops : 输出系统属性，等同于System.getProperties() 示例12$ jinfo -flag 11494-XX:CMSInitiatingOccupancyFraction=80]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm(3):GC算法 垃圾收集器]]></title>
    <url>%2F2017%2F10%2F26%2Fjvm-3-GC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[这篇文件将给大家介绍GC都有哪几种算法，以及JVM都有那些垃圾回收器，它们的工作原理。 概述垃圾收集 Garbage Collection 通常被称为“GC”，它诞生于1960年 MIT 的 Lisp 语言，经过半个多世纪，目前已经十分成熟了。jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的. 对象存活判断判断对象是否存活一般有两种方式： 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。 在Java语言中，GC Roots包括： 虚拟机栈中引用的对象。 方法区中类静态属性实体引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI引用的对象。 垃圾收集算法标记 -清除算法“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。 它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 复制算法“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。 标记-压缩算法复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。 根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存 分代收集算法GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。 “分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。 垃圾收集器 如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现 Serial收集器串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停） 参数控制：-XX:+UseSerialGC 串行收集器 ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩 参数控制： -XX:+UseParNewGC ParNew收集器-XX:ParallelGCThreads 限制线程数量 Parallel收集器Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩 参数控制：-XX:+UseParallelGC 使用Parallel收集器+ 老年代串行 Parallel Old 收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供 参数控制： -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行 CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。 从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew） 优点: 并发收集、低停顿缺点: 产生大量空间碎片、并发阶段会降低吞吐量 参数控制： -XX:+UseConcMarkSweepGC 使用CMS收集器-XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长-XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC后，进行一次碎片整理-XX:ParallelCMSThreads 设定CMS的线程数量（一般情况约等于可用CPU数量） G1收集器G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点： 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。 可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。 G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。 收集步骤： 1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark) 2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。 3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。 4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。 5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。 6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。 常用的收集器组合 服务器31 新生代GC策略 老年老代GC策略 说明 组合1 Serial Serial Old Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。 组合2 Serial CMS+Serial Old CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。 组合3 ParNew CMS 使用-XX:+UseParNewGC选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用ParNew GC策略。 组合4 ParNew Serial Old 使用-XX:+UseParNewGC选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。 组合5 Parallel Scavenge Serial Old Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。 组合6 Parallel Scavenge Parallel Old Parallel Old是Serial Old的并行版本 组合7 G1GC G1GC -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC #开启；-XX:MaxGCPauseMillis =50 #暂停时间目标；-XX:GCPauseIntervalMillis =200 #暂停间隔目标；-XX:+G1YoungGenSize=512m #年轻代大小；-XX:SurvivorRatio=6 #幸存区比例]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm(2):JVM内存结构]]></title>
    <url>%2F2017%2F10%2F26%2Fjvm-2-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[所有的Java开发人员可能会遇到这样的困惑？我该为堆内存设置多大空间呢？OutOfMemoryError的异常到底涉及到运行时数据的哪块区域？该怎么解决呢？其实如果你经常解决服务器性能问题，那么这些问题就会变的非常常见，了解JVM内存也是为了服务器出现性能问题的时候可以快速的了解那块的内存区域出现问题，以便于快速的解决生产故障。 先看一张图，这张图能很清晰的说明JVM内存结构布局。 JVM内存结构主要有三大块：堆内存、方法区和栈。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配； 方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。 在通过一张图来了解如何通过参数来控制各区域的内存大小 控制参数 -Xms设置堆的最小空间大小。 -Xmx设置堆的最大空间大小。 -XX:NewSize设置新生代最小空间大小。 -XX:MaxNewSize设置新生代最大空间大小。 -XX:PermSize设置永久代最小空间大小。 -XX:MaxPermSize设置永久代最大空间大小。 -Xss设置每个线程的堆栈大小。 没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。 老年代空间大小=堆空间大小-年轻代大空间大小 从更高的一个维度再次来看JVM和系统调用之间的关系 方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。 下面我们详细介绍每个区域的作用 Java堆（Heap）对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区（Method Area）方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。 Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 方法区有时被称为持久代（PermGen）。 所有的对象在实例化后的整个运行周期内，都被存放在堆内存中。堆内存又被划分成不同的部分：伊甸区(Eden)，幸存者区域(Survivor Sapce)，老年代（Old Generation Space）。 方法的执行都是伴随着线程的。原始类型的本地变量以及引用都存放在线程栈中。而引用关联的对象比如String，都存在在堆中。为了更好的理解上面这段话，我们可以看一个例子： 123456789101112import java.text.SimpleDateFormat;import java.util.Date;import org.apache.log4j.Logger; public class HelloWorld &#123; private static Logger LOGGER = Logger.getLogger(HelloWorld.class.getName()); public void sayHello(String message) &#123; SimpleDateFormat formatter = new SimpleDateFormat("dd.MM.YYYY"); String today = formatter.format(new Date()); LOGGER.info(today + ": " + message); &#125;&#125; 这段程序的数据在内存中的存放如下： 通过JConsole工具可以查看运行中的Java程序（比如Eclipse）的一些信息：堆内存的分配，线程的数量以及加载的类的个数； 程序计数器（Program Counter Register）程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 JVM栈（JVM Stacks）与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 本地方法栈（Native Method Stacks）本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 哪儿的OutOfMemoryError对内存结构清晰的认识同样可以帮助理解不同OutOfMemoryErrors： 1Exception in thread “main”: java.lang.OutOfMemoryError: Java heap space 原因：对象不能被分配到堆内存中 1Exception in thread “main”: java.lang.OutOfMemoryError: PermGen space 原因：类或者方法不能被加载到持久代。它可能出现在一个程序加载很多类的时候，比如引用了很多第三方的库； 1Exception in thread “main”: java.lang.OutOfMemoryError: Requested array size exceeds VM limit 原因：创建的数组大于堆内存的空间 1Exception in thread “main”: java.lang.OutOfMemoryError: request &lt;size&gt; bytes for &lt;reason&gt;. Out of swap space? 原因：分配本地分配失败。JNI、本地库或者Java虚拟机都会从本地堆中分配内存空间。 1Exception in thread “main”: java.lang.OutOfMemoryError: &lt;reason&gt; &lt;stack trace&gt;（Native method） 原因：同样是本地方法内存分配失败，只不过是JNI或者本地方法或者Java虚拟机发现]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
